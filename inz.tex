% !TeX spellcheck = pl_PL
\documentclass[12pt]{report}

\usepackage{amssymb} % symbol kąta
\usepackage[polish]{babel} % polskie nazwy
\usepackage[T1]{fontenc} % polskie znaki
\usepackage[margin=1.0in]{geometry} % marginesy
\usepackage[utf8]{inputenc}
\usepackage{listingsutf8} % bloki kodu
\usepackage{lmodern} % font
\usepackage{color} % kolory
\usepackage{indentfirst} % wcięcie w pierwszej linii paragrafu
\usepackage{graphicx} % obrazy
\usepackage{float} % dla image [H]
\usepackage{amsmath,amsthm,amssymb,mathtools} % matematyka dowód
\usepackage{changepage} % matematyka dowód
\usepackage{siunitx} % wyrównanie do kropki
\usepackage{makecell} % wyrównania nagłówków
\usepackage{hyperref} % bez obwódek wokół linków
\hypersetup{
	colorlinks,
	citecolor=black,
	filecolor=black,
	linkcolor=black,
	urlcolor=magenta
}
\usepackage{caption} % link przenosi do góry obrazka
\usepackage{svg}

% bez odstępu w itemize
\let\tempone\itemize
\let\temptwo\enditemize
\renewenvironment{itemize}{\tempone\setlength{\itemsep}{0cm}}{\temptwo}

\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}  

% Obrazki
% ścieżki do obrazków
\graphicspath{ {img/} }

% obrazek {nazwa.png}{opis}{rozmiar}{H - wymuszanie}
\newcommand{\imgint}[4]{
	\begin{figure}[{#4}]
		\centering
		\includegraphics[width=#3\textwidth]{#1}
		\caption{#2}
		\label{#1}
	\end{figure}
}

% obrazek {nazwa.png}{opis}{rozmiar} (bez wymuszania)
\newcommand{\imgcs}[3]{\imgint{#1}{#2}{#3}{}}

% obrazek {nazwa.png}{opis} (domyślny rozmiar)
\newcommand{\img}[2]{\imgcs{#1}{#2}{0.7}}

% obrazek {nazwa.png}{opis}{rozmiar} (wymuszona pozycja)
\newcommand{\imgh}[3]{\imgint{#1}{#2}{#3}{H}}

% dwa obrazki {1}{opis 1}{2}{opis 2}{H - wymuszanie}
\newcommand{\imgintss}[5]{
	\begin{figure}[{#5}]
		\centering
		\begin{minipage}{.45\textwidth}
			\centering
			\includegraphics[width=1\linewidth]{#1}
			\caption{#2}
			\label{#1}
		\end{minipage}%
		\hfill
		\begin{minipage}{.45\textwidth}
			\centering
			\includegraphics[width=1\linewidth]{#3}
			\caption{#4}
			\label{#3}
		\end{minipage}
	\end{figure}
}

% dwa obrazki {1}{opis 1}{2}{opis 2} (bez wymuszania)
\newcommand{\imgss}[4]{\imgintss{#1}{#2}{#3}{#4}{}}

% dwa obrazki {1}{opis 1}{2}{opis 2} (wymuszona pozycja)
\newcommand{\imghss}[4]{\imgintss{#1}{#2}{#3}{#4}{H}}

% tabela z wynikami {nazwa.txt}{opis}
\newcommand{\tab}[2]{
	\begin{table}
		\centering
		\caption{#2}
		\vspace{0.3cm}
		\input{#1}
	\end{table}
}

% nagłowek tabeli bold
\renewcommand\theadfont{\bfseries}

% interfejs I2S
\newcommand{\isqs}{$\text{I}^{2}\text{S}$}
% side-set
\newcommand{\sset}{\lstinline|side-set|}

% Listingi kodu
% Style
\lstdefinestyle{default}{
	basicstyle={\ttfamily \footnotesize},
	morekeywords={},
	numbers=left,
	backgroundcolor=\color{lbcolor}
}
\lstdefinestyle{pio}{
	basicstyle={\ttfamily \footnotesize},
	morekeywords={out, side, jmp, set},
	numbers=left,
	backgroundcolor=\color{lbcolor}
}
\lstdefinestyle{scad}{
	basicstyle={\ttfamily \footnotesize},
	morekeywords={module, color, for, translate},
	numbers=left,
	backgroundcolor=\color{lbcolor}
}
\lstdefinestyle{c}{
	basicstyle={\ttfamily \footnotesize},
	morekeywords={while, if, false, DBG_ON, f_read, DBG_OFF},
	numbers=left,
	backgroundcolor=\color{lbcolor}
}

% input listing {style}{caption}{path}
\newcommand{\lstfile}[3]{
	\noindent
	\hspace{0.1\linewidth}
	\begin{minipage}{0.8\linewidth}
		\lstinputlisting[style=#1, caption={#2}, label={#3}]{#3}
	\end{minipage}
	\vspace{0.3cm}
}


\begin{document}
\lstset{inputencoding=utf8, basicstyle=\ttfamily}

\title{Odbiornik internetowych stacji radiowych \\
	\vspace{0.2cm}
	\large Praca Inżynierska \\
	\large ...}
\author{Norbert Morawski}

\maketitle
\setcounter{tocdepth}{1}
\tableofcontents
\pagebreak

\chapter{Cel prac i wizja produktu}
	W tym rozdziale opisano jak będzie wyglądał końcowy produkt. Zwrócono też uwagę na to jak będzie przebiegała jego realizacja i jakie ryzyka mogą wystąpić.
	
	\section{Opis problemu}
		Radio internetowe staje się co raz popularniejsze. Wolność transmisji, brak regulacji pasma radiowego powodują, że wiele niezależnych stacji radiowych wybiera właśnie to medium przekazu. Jednak większość funkcjonujących współcześnie odbiorników nie posiada funkcji odbioru strumienia internetowego. Celem pracy jest wykonanie kompletnego przenośnego urządzenia, które umożliwiłoby odbiór takich stacji.
		
	\section{Rola produktu}
		Radio jest skierowane do osób z małą wiedzą technologiczną. To znaczy, obsługa urządzenia powinna być prosta i intuicyjna. Nie powinny być wymagane żadne dodatkowe elementy do eksploatacji (zewnętrzne głośniki, specjalna ładowarka). Produkt ma być kompletnym urządzeniem gotowym do odbioru radia. Całość będzie zamknięta w obudowie. Na rysunku~\ref{1/radio_proj_trimmed} przedstawiony został projekt wizualny radia. Rysunek~\ref{1/PicoRadio_blocks} przedstawia uproszczony schemat blokowy urządzenia.
		
		\imgcs{1/radio_proj_trimmed}{Projekt wizualny radia (z zachowanymi proporcjami)}{0.9}
		\imgcs{1/PicoRadio_blocks}{Schemat blokowy radia}{1}
		
	\section{Współpracujące systemy}
		Oczywistym współpracującym systemem jest w przypadku tego projektu serwer strumieniujący radio internetowe. Standardem kodowania wykorzystywanym przez serwery jest format MP3 lub AAC/AAC+. Drugim współpracującym systemem jest baza danych zawierająca stacje radiowe. Baza taka powinna umożliwiać zapytania poprzez udokumentowane i dostępne API. List baz brana pod uwagę przy projektowaniu urządzenia:
		\begin{itemize}
			\item Radio-browser\textsuperscript{\cite{radio-browser}}
			\item fmstream\textsuperscript{\cite{fmstream}}
		\end{itemize}
		
		Druga baza, choć obszerniejsza (86,000 a 38,578 stacji), nie udostępnia interfejsu dla wszystkich. Autor życzy sobie osobistej prośby o dostęp, która na ten moment została wysłana i czeka na odpowiedź.
		
	\section{Wymagania}
		Główną funkcją budowanego urządzenia ma być możliwość odtwarzania radia internetowego.
		
		\subsection{Wymagane funkcjonalności}
			\begin{itemize}
				\item odtwarzanie stacji internetowych,
				\item wstrzymywanie odtwarzania,
				\item prezentacja na zintegrowanym wyświetlaczu aktualnego stanu,
				\item regulacja głośności odtwarzania,
				\item lista stacji,
				\item lista ulubionych stacji.
			\end{itemize}
			
			\paragraph{Dodatkowe funkcjonalności (niewymagane)}
			\begin{itemize}
				\item odtwarzanie plików z nośnika przenośnego,
			\end{itemize}
		
			\paragraph{Oczekiwany produkt}
			\begin{itemize}
				\item W pełni funkcjonalny prototyp urządzenia realizującego funkcje odbiornika internetowych stacji radiowych,
				\item Dokumentacja techniczna pozwalająca na zbudowanie urządzenia oraz rozwój jego oprogramowania układowego.
			\end{itemize}
		
		\subsection{Wymagania niefunkcjonalne}
			Urządzenie ma być wykonane z wykorzystaniem mikrokontrolera, lub płytki rozwojowej opartej o mikrokontroler. Rozwiązanie powinno obsługiwać połaczenie z Internetem, np. WiFi, do pobierania strumienia danych audio z serwera oraz musi poradzić sobie z dekodowaniem formatu MP3 lub AAC w czasie rzeczywistym.
			
			Zdecydowano się też na miniaturyzację wyświetlacza i zastosowanie do obsługi urządzenia kilku przycisków. Z uwagi na małą moc obliczeniową mikrokontrolera, regulacja głośności odbywać się będzie analogowym potencjometrem.
		
	\section{Przegląd konkurencyjnych rozwiązań}
		Ceny komercyjnych adapterów radia internetowego zaczynają się od ok. 330 zł za produkt powystawowy (Rysunek~\ref{1/radio_adapter}). Wieże z wbudowaną opcją radia internetowego to koszt rzędu 230 zł za najtańszy produkt z głośnikiem mono (Rysunek~\ref{1/radio_tanie}) lub ok. 370 zł za wersję stereo (Rysunek~\ref{1/radio_drogie}). Chciałbym mój produkt zrealizować kosztem przystępnym dla hobbystycznego amatora elektroniki. Wykluczam zatem użycie gotowych, drogich płytek rozwojowych, takich jak np. \textit{STM32F746G-Disco} kosztującej 389 zł (Rysunek~\ref{1/botland_stm}).
		
		Jednym z założeń pracy jest skonstruowanie systemu, którego dokumentacja pozwoli dowolnemu informatykowi/elektronikowi na skonstruowanie podobnego urządzenia i modyfikację jego oprogramowania. Projekt sam w sobie jest ciekawy ponieważ w Internecie mało jest prób konstrukcji radia internetowego opartego o Raspberry Pi Pico. Nie znaleziono żadnych projektów dekodujących samodzielnie format MP3.  Jeden z projektów\textsuperscript{\cite{radio_pico1}} używa sprzętowego dekodera MP3 (przedstawiony na rysunku~\ref{1/radio_mp3}). Większość odtwarzaczy własnej konstrukcji opiera się o pełnoprawny komputer jednopłytkowy Raspberry Pi, który jest obecnie trudno dostępny.
		
		Urządzenie będzie także posiadać prosty i intuicyjny interfejs, aby trafić do szerokiej grupy odbiorców. Zastosowane zostaną ogniwa ładowalne, tak, aby użytkownik przy pomocy np. portu USB mógł je naładować po wyczerpaniu.
		
		\img{1/radio_adapter}{Adapter radia internetowego \textsuperscript{\cite{radio_adapter}}}
		\imgss{1/radio_tanie}{Radio internetowe mono \textsuperscript{\cite{radio_tanie}}}{1/radio_drogie}{Radio internetowe stereo \textsuperscript{\cite{radio_drogie}}}
		
		\img{1/botland_stm}{Droga płytka STM\textsuperscript{\cite{botland_stm}}}
		
		\img{1/radio_mp3}{Sprzętowy dekoder MP3 \textsuperscript{\cite{radio_vs1003}}}
		
	\section{Analiza technologiczna}
		Do realizacji projektu wybrany został bogato wyposażony mikrokontroler Raspberry Pi RP2040\textsuperscript{\cite{rp2040}}. Jednak pojawiły się obawy o możliwość dekodowania formatu MP3 w czasie rzeczywistym.
		
		\subsection{Biblioteka dekodująca}
			Standardowa ramka MP3 odtwarzana jest przez ok. 26ms. Początkowe testy z biblioteką \lstinline|minimp3|\textsuperscript{\cite{minimp3}} do dekodowania formatu MP3 nie przyniosły obiecujących rezultatów.  Przy użyciu tej biblioteki ramka była dekodowana w 90ms. Jednak wykorzystanie \lstinline|helixmp3|\textsuperscript{\cite{helixmp3}} pozwoliło na zdekodowanie ramki w 22ms (80\% dostępnego czasu) przy domyślnym taktowaniu procesora.  Używa ona matematyki stałoprzecinkowej, co w przypadku jednostki bez koprocesora matematycznego stanowi dużą przewagę.
			
			Martwiące może się wydawać poświęcenie 80\% czasu procesora na dekodowanie formatu, jednak jako że mikrokontroler jest dwurdzeniowy, cały jeden rdzeń może zostać wykorzystany do dekodowania.
		
		\subsection{Oprogramowanie}
			Oprogramowanie zostanie napisane w języku C++ z wykorzystaniem środowiska \lstinline|pico-sdk|\textsuperscript{\cite{pico_sdk}}.  W środowisko brak wbudowanego centralnego systemu zarządzającego przepływem informacji oraz zadaniami, zatem do projektu dołączone zostało jądro systemu czasu rzeczywistego FreeRTOS\textsuperscript{\cite{freertos_kernel}}
	
	\section{Ryzyko}
		Należy uwzględnić ryzyko opóźnień w ustalonym trybie prac. Tworzenie oprogramowania wiąże się z ryzykiem dotarcia w ślepy zaułek i konieczności gruntownego przeprojektowania części systemów. Dostosowanie platformy pod centralny system czasu rzeczywistego stanowi przykład takiego opóźnienia. Posiadając jedną płytkę Raspberry Pi Pico, jej uszkodzenie również może powodować opóźnienia w realizacji projektu. Warto zaopatrzyć się w więcej niż jedną sztukę krytycznych elementów. Niespodziewane problemy z jakością oprogramowania, takie jak na przykład ciężko reprodukowalne błędy w strumieniowaniu audio, także mogą przyczynić się do wielu godzin poszukiwania przyczyn takiego zachowania aplikacji.
		Dobre planowanie, rzetelne projektowanie i tworzenie aplikacji powinny umniejszyć rolę w.w. ryzyk.
	
	\section{Słownik pojęć}
	\begin{itemize}
%			\item MP3 (\textit{MPEG-1 Audio Layer 3}) -- popularny format zapisu dźwięku; implementuje stratną kompresję,
		\item AAC/AAC+ (\textit{Advanced Audio Coding}) -- inny format dźwięku z kompresją stratną
%			\item Li-ion -- akumulatory Litowo-jonowe (ładowalne)
		\item Raspberry Pi -- komputery jednopłytkowe tworzone przez Raspberry Pi Foundation
		\item Raspberry Pi Pico -- płytki rozwojowe oparte o mikrokontroler RP2040 (produkowane również przez Raspberry Pi Foundation)
		\item \textit{Cortex M0+}
		\item PWM
		\item DMA
		\item PIO
		\item DAC
		\item \isqs{} proto
		\item PCM
		\item SIO
		\item TCP
		\item TLS
%			TODO fill in dict
	\end{itemize}

\chapter{Projekt interfejsu i interakcji z użytkownikiem}
	W rozdziale drugim skupiono się na aspektach funkcjonalności produktu jak i projekcje interakcji z użytkownikiem.\\
	
	Najważniejszym elementem planowania projektu z perspektywy użyteczności dla klienta jest plan wygodnego i intuicyjnego interfejsu użytkownika. Dodatkową komplikacją jest fakt, że urządzenie będzie miało do dyspozycji tylko niewielki wyświetlacz i kilka przycisków. Należy więc zadbać, żeby przy tym niewielkim asortymencie sprzętu dało się przekazać wszystkie informacje i ustalić co użytkownik planuje zrobić w następnej kolejności.
		
	\section{Projekt interfejsu}
		Do zaprojektowania ekranów posłużyło narzędzie Figma\textsuperscript{\cite{figma}}. Na rysunku~\ref{2/interface/all} przedstawiono jak wyglądają poszczególne okna oraz jak użytkownik może przemieszczać się  pomiędzy nimi. Na rysunkach \ref{2/interface/real1} oraz \ref{2/interface/real2} umieszczono zdjęcia interfejsu na rzeczywistym wyświetlaczu.
		
		\paragraph{Ikony statusu}
			Przy projektowaniu interfejsów poczyniono założenie, że ikony statusowe (połączenie WiFi/włożona karta SD/etc.) znajdować się będą na górze ekranu. Nie będą one klikalne.
			
		\paragraph{Ikony akcji}
			Na ekranach w dolnej części umieszczono ikony akcji. Jest to np. ikona wstecz lub wyszukaj. Użytkownik dzięki nim będzie mógł przeprowadzać dodatkowe akcje.
		
		$ $\\
		Przy wyświetlaniu listy (np. wyników wyszukiwania lub listy ulubionych stacji) kliknięcie w daną pozycję powoduje zaakceptowanie jej i otworzenie następnego ekranu.
	
		\imgcs{2/interface/all}{Przemieszczanie się pomiędzy ekranami}{0.9}
		\imgss{2/interface/real1}{Wyszukiwanie stacji}{2/interface/real2}{Wyniki wyszukiwania}
	
	\section{Interakcja z użytkownikiem}
	W trakcie projektowania ekranów konieczne stało się założenie użycia 5 przycisków. Cztery z nich zostaną użyte do nawigacji prawo/lewo/góra/dół, a pozostały (środkowy) do wykonania wybranej akcji. Poniżej przedstawione zostały wybrane scenariusze obsługi radia.
%		Nawigacja oparta jest na siatce przycisków, przy czym może być ona nieregularna (różna liczba przycisków w różnych wierszach). 
	
	\imgh{2/btn/1}{Krok w dół na liście}{0.7}
	Na rysunku~\ref{2/btn/1} widać jak użytkownik aby poruszyć się w dół listy stacji naciska dolny przycisk. Powrót do \textit{Radio 1} jest oczywiście możliwy poprzez naciśnięcie górnego przycisku.
	
	\imgh{2/btn/2}{Przewinięcie listy stacji do góry}{0.7}
	Po dojściu do czwartej pozycji na liście, jeżeli na liście jest więcej niż 4 stacje, po naciśnięciu dolnego przycisku, zgodne z rysunkiem~\ref{2/btn/2}, kursor zostanie przeniesiony do piątej stacji. Należy zwrócić uwagę na zmianę położenia paska przewijania (po prawej stronie).
	
	\imgh{2/btn/3}{Przejście z listy do ikon akcji}{0.7}
	Jeżeli wskaźnik znajduje się na końcu listy (pasek przewijania w skrajnie dolnej pozycji), po naciśnięciu przycisku w dół, kursor znajdzie się w pasku ikon akcji. Sytuację tę przedstawia rysunek \ref{2/btn/3}. Powrót na listę stacji jest możliwy przy pomocy górnego przycisku.
	
	\imghss{2/btn/4r}{Przejście w prawo}{2/btn/4l}{Przejście w lewo}
	Poruszanie się w obrębie jednego wiersza zostało zrealizowane poprzez przyciski \mbox{lewo/prawo}. Przedstawiają to rysunki \ref{2/btn/4r} i \ref{2/btn/4l} na przykładzie dwóch ikon akcji.
	
	\imgh{2/btn/5}{Akceptacja wyboru}{0.7}
	Przycisk środkowy służy do wykonania akcji. Jeżeli kursor jest ustawiony na liście, możemy rozpocząć odtwarzanie naciskając go (rysunek \ref{2/btn/5})
	
	\imghss{2/err1}{Błąd odtwarzania}{2/err2}{Błąd ładowania stacji z bazy danych}
	Czasami w komunikacji z serwerem może wystąpić błąd. Takie sytuacje są zgłaszane użytkownikowi poprzez ekrany błędów widoczne na rysunkach \ref{2/err1} i \ref{2/err2} (czerwone tło). Aby wyjść z takiego ekranu nacisnąć dowolny przycisk.

\chapter{Wybrane aspekty realizacji}
	W tym rozdziale wyjaśnione zostało jak zbudowany został projekt.
	
	\section{Moduły projektu}
		W kodzie starano się zachować porządek. Wydzielone zostały główne funkcjonalne elementy i na podstawie tego podziału stworzona została struktura modularna przedstawiona na rysunku \ref{3/pico-radio-code-block-diagram}.
		\imgh{3/pico-radio-code-block-diagram}{Schemat blokowy modułów projektu}{0.7}
		
		\subsection{Moduły własne}
			Większość kodu projektu zawiera katalog \lstinline|libs|. W nim znajdują się poszczególne moduły (nazwane odpowiednimi nazwami podfolderów). Wszystkie wypisane w tej sekcji zostały zaimplementowane samodzielnie, chyba, że zaznaczono inaczej. Dla przejrzystości pogrupowano moduły wg ich ról.
		
			\paragraph{Wejście}
				\begin{itemize}
					\item \lstinline|analog| -- dostęp do pomiaru poziomu naładowania baterii
					\item \lstinline|buttons| -- funkcje do obsługi przycisków
					\item \lstinline|sd| -- wykrywanie i montowanie karty SD z systemem plików FAT
				\end{itemize}
		
			\paragraph{Wyjście}
				\begin{itemize}
					\item \lstinline|display| -- obsługa wyświetlacza
					\begin{itemize}
						\item \lstinline|assets| -- artefakty; takie jak czcionki i ikony
						\item \lstinline|screens| -- widoki użytkownika
						\item \lstinline|tft| -- niskopoziomowa obsługa ekranu ze sterownikiem ST7735s. Kod inicjalizacji i przesyłania pikseli zaczerpnięty z \textit{Adafruit-ST7735-Library}\textsuperscript{\cite{adafruit_st7735}}
					\end{itemize}
				\end{itemize}
			
			\paragraph{Obsługa list}
				\begin{itemize}
					\item \lstinline|list| -- obsługa list jak i ich ładowanie (wyszukiwanie/ulubione/listing plików na karcie SD)
				\end{itemize}
			
			\paragraph{Odtwarzanie}
				\begin{itemize}
					\item \lstinline|mcorefifo| -- funkcje pomocnicze do przesyłania komunikatów z rdzenia 1 do 0
					\item \lstinline|player| -- kontrola i odtwarzanie plików/strumieni internetowych
					\begin{itemize}
						\item \lstinline|decode| -- abstrakcje/implementacje dekodowania typów i odczytywania źródeł danych
						\item \lstinline|metadata| -- dekodowanie metadanych w różnych formatach audio
					\end{itemize}
				\end{itemize}
		
			\paragraph{Źródła danych}
				\begin{itemize}
					\item \lstinline|ds| -- interfejs \lstinline|DataSource| łączący różne źródła danych
					\item \lstinline|httpc| -- klient protokołu HTTP
					\item \lstinline|lfs| -- kod integrujący system plików LittleFS\textsuperscript{\cite{littlefs}}
				\end{itemize}
			
			\paragraph{Wi-Fi}
				\begin{itemize}
					\item \lstinline|wifi| -- obsługa sieci bezprzewodowych
				\end{itemize}
		
			\paragraph{Pliki pomocnicze}
				\begin{itemize}
					\item \lstinline|circularbuffer| -- bufor kołowy
					\item \lstinline|static| -- statycznie alokowane bufory
					\item \lstinline|util| -- funkcje pomocnicze
					\item \lstinline|settings| -- wpisy na ekranie ustawień
				\end{itemize}
	
		\subsection{Moduły zewnętrzne}
		W folderze \lstinline|libs/external| umieszczone zostały moduły dostarczone z zewnątrz:
		\begin{itemize}
			\item \lstinline|FreeRTOS-Kernel| -- jądro systemu czasu rzeczywistego FreeRTOS\textsuperscript{\cite{freertos_kernel}}
			\item \lstinline|helixmp3| -- biblioteka dekodująca format MP3\textsuperscript{\cite{helixmp3_repo}} oryginalnie napisana przez firmę \textit{RealNetworks}\textsuperscript{\cite{realnetworks}}
			\item \lstinline|littlefs| -- system plików LittleFS\textsuperscript{\cite{littlefs}}
			\item \lstinline|sd_lib| -- biblioteka FatFS\textsuperscript{\cite{fatfs}} wraz z kodem dostępu do karty SD\textsuperscript{\cite{sdfs}}
		\end{itemize}

	\section{Odtwarzanie dźwięku}
%		Zanim radio urosło do rangi pracy inżynierskiej, było ono moim prywatnym projektem. Chciałem poznać mikrokontroler RP2040. Poznać \lstinline|pico-sdk|. Po pierwszym kontakcie na \textit{Systemach Wbudowanych} środowisko stworzone wokół przystępnej cenowo płytki Raspberry Pi Pico wydawało się ciekawe i interesujące. Mikrokontroler ten, bogato wyposażony, stanowił idealną podstawę do stworzenia czegoś, co zawsze chciałem zbudować: odtwarzacza dźwięku. Przy okazji, tworząc taki projekt mogłem zaznajomić się ze wszystkimi ważniejszymi peryferiami układu (wykorzystałem m.in. PWM, DMA, a także później PIO).
%		
%		Szybko jednak okazało się, że odtwarzania dźwięku za pomocą wbudowanego układu PWM jest niewystarczające. Dźwięk był zbyt niskiej jakości aby nadawał się do odtwarzania muzyki. Wykorzystałem układ TDA1543 jako przetwornik cyfrowo-analogowy. Projekt odtwarzał tylko pliki WAV i wyglądał tak, jak na rysunku \ref{3/pr_wav}.
%		
%		Wtedy też wybrałem ten temat pracy inżynierskiej. Lecz zanim mogłem kontynuować, należało szybko zorientować się, czy płytka poradzi sobie z dekodowaniem formatu MP3 w czasie rzeczywistym. Dzięki bibliotece \lstinline|helixmp3| używającej arytmetyki stałoprzecinkowej, było to możliwe.
%		
%		\imgcs{3/pr_wav}{Projekt we wczesnych fazach rozwoju}{0.45}
		
%		\subsection{Model przetwarzania dźwięku}
		
%			\imgcs{3/pipeline}{Koncepcja wielowątkowego dekodowania}{0.8}
			
		Odtwarzanie dźwięku odbywa się za pomocą zewnętrznego przetwornika DAC. Mikrokontroler wysyła dźwięk w formacie PCM protokołem \isqs{} do specjalizowanego układu z wykorzystaniem DMA. Drugi rdzeń procesora wykorzystywany jest wyłącznie do dekompresji formatów audio.
		
	%	TODO opisać tutaj co robi player.cpp (zmienna dec, funkcje publcizne)
		
		\subsection{Komunikacja z przetwornikiem}
			W programie utworzony został bufor nieskompresowanego dźwięku PCM \lstinline|audio_pcm|. Ma on konfigurowalny rozmiar wyrażony w jednostkach 32-bitowych (2 kanały * 16-bitowa próbka). Przekazywany jest on do systemu DMA.
		
			\subsubsection{PIO}
				\imgh{3/pio_block}{Pojedynczy blok PIO (dokumentacja RP2040\textsuperscript{\cite{pico_pdf}}, strona 309)}{0.7}
				
				RP2040 posiada 8 programowalnych maszyn stanów, zgrupowanych w 2 bloki. W ramach jednego bloku (Rys. \ref{3/pio_block}) współdzielą one pamięć 32 instrukcji. Może wydawać się to mało, lecz instrukcje te są bardzo skondensowane.
				
				\imgh{3/pio_instr}{Zestaw instrukcji PIO (dokumentacja RP2040, strona 320)}{0.7}
				Język programowania to własnościowy język z rodziny assembler. Do środowiska \lstinline|pico-sdk| dołączony jest assembler \lstinline|picoasm|. Zestaw instrukcji przedstawiono na rysunku \ref{3/pio_instr}. Jak wspomniano wcześniej, instrukcje są skondensowane, to znaczy mogą wykonywać wiele operacji na raz. Na przykład opóźniać wykonanie programu lub ustawiać osobny rodzaj wyjść typu \sset{}.
				Instrukcja skoku obsługuje także dekrementację zmiennej w warunku. Same maszyny mogą mieć ustawiony dowolny adres wejścia i zapętlenia programu. Oszczędza to kilka instrukcji.
				
				\paragraph{Wyjścia typu \sset{}}
					Jest to specjalny rodzaj wyjść, które mogą być ustawiane równocześnie z wykonywaniem innych instrukcji. Są szczególnie przydatne przy ustawianiu linii zegarowych i pozostałych linii kontrolnych. Minusem wykorzystania ustawiania wyjść \textit{na boku} jest konieczność poświęcenia możliwości opóźniania programu. W liście instrukcji pole \sset{} jest współdzielone z polem \lstinline|delay|. Jednak zaimplementowany program nie używa opóźnień.
				
				\imgh{3/pio_i2s_docs}{Przebieg czasowy protokołu \isqs{} (dokumentacja TDA1543\textsuperscript{\cite{tda_pdf}}, strona 9)}{0.9}
				Dzięki tym blokom, możliwe jest dodanie do mikrokontrolera dowolnego protokołu danych bez zbytniego obciążenia procesora jego pełną symulacją. W ramach pracy został stworzony blok obsługi interfejsu \isqs{}, który serializuje dane dostarczane przez DMA i wysyła do układu DAC.
				Dokumentacja protokołu \isqs{} została zaczerpnięta z dokumentacji układu TDA1543. Przedstawia ją rysunek \ref{3/pio_i2s_docs}. Jak widać zmiana kanału (kodowanego poziomem linii \lstinline|WS|)  musi nastąpić przed wysłaniem ostatniego bitu poprzedniego kanału (\lstinline|LSB|, czyli \textit{Least Significant Bit}, najmniej znaczący bit kanału lewego). Z tego powodu program wydłużył się do 8 instrukcji. Niektóre układy obsługują protokół \textit{left-just}, który nie posiada tego ograniczenia, jednak z uwagi na niewystarczającą dokumentacje i małe wsparcie przez układy, wybrany został klasyczny \isqs{}.
				
				\lstfile{pio}{Kod programu \isqs{}}{lst/3/i2s.pio}
				
				Kod tego bloku przedstawiony został na listingu \ref{lst/3/i2s.pio}. Poniżej omówione zostało jego działanie:
				\begin{itemize}
					\item Linia nr 3 ustawia ile bitów jest typu \lstinline|side-set|. Bity \lstinline|side-set| są wykorzystywane odpowiednio do: ustawienia linii \lstinline|WS| i linii \lstinline|BCK|.
					
					\item punktem wejścia programu jest linia nr 18. Ustawia ona liczbę powtórzeń i inicjalizuje linię \lstinline|WS| na 1 (kanał prawy) oraz linię \lstinline|BCK| na 1. Odwrócenie kolejności kanałów związane jest z kolejnością bajtów typu \textit{little-endian}). Następnie program automatycznie zapętla się do pierwszej instrukcji.
					
					\item Instrukcja \lstinline|out| powoduje wystawienie na linię \lstinline|DATA| jednego bitu z rejestru przesuwnego danych. \textit{Na boku} przełącza linię zegarową w stan niski
					
					\item Instrukcja \lstinline|jmp| najpierw sprawdza wartość rejestru \lstinline|X|. Jeżeli jest ona niezerowa to dekrementuje ją i skacze do etykiety \lstinline|right|. Pętla ta wykonuje się 15 razy.
					
					\item W linii nr 9 następuje transmisja najmniej znaczącego bitu kanału prawego. Zgodnie z dokumentacją musimy już zmienić stan linii \lstinline|WS| na 0 (kanał lewy). Następnie rejestr \lstinline|X| jest ponownie inicjalizowany na wartość 14.
					
					\item Linie 13-18 powtarzają transmisje zgodnie z opisem powyżej, ale tym razem dla kanału lewego.
				\end{itemize}
				
				Instrukcja \lstinline|out| czeka na dane w buforze automatycznie.
			
			\subsubsection{DMA}
				\imgcs{3/dma_chain}{Kolejkowanie kanałów DMA}{0.55}
				Podsystem bezpośredniego dostępu do pamięci wysyła dane do maszyn stanu PIO. Aby móc prowadzić nieprzerwaną transmisję, wykorzystane zostały dwa kanały z 12 dostępnych w układzie. Schemat działania przedstawiony został na rysunku \ref{3/dma_chain}. W momencie gdy jeden kanał skończy transfer, automatycznie uruchamiany jest drugi kanał. Taką funkcjonalność oferuje sprzętowo RP2040. Wywoływane jest także przerwanie, które zgłasza procesorowi potrzebę załadowania nowych danych.
		
		\subsection{Dekompresja formatów}
			\label{sec:decode}
%			\imgh{3/rb_chart_new}{Udział kodeków w stacjach radiowych}{0.9}
%			
%			Wybór padł na format MP3. Jest on popularnym formatem zapisu skompresowanego dźwięku. Wg agregatu stacji radiowych \textit{Radio Browser}\textsuperscript{\cite{radio_browser_codecs}}, około 66\% wszystkich wpisów używa kodeku MP3 (w przypadku polskich stacji jest to około 60\%). Graficznie procentowe udziały przedstawia rysunek \ref{3/rb_chart_new}.
%			
%			\paragraph{Droga dalszego rozwoju}
%				Najbardziej korzystną drogą rozwoju jest implementacja dekodowania AAC/AAC+. Na ten moment nie zostało to zrobione.
%			$ $\\
		
%		\subsubsection{Architektura programowa dekodera}
			\imgh{3/PicoRadio-sound-decoding}{Architektura dekodowania dźwięku}{0.95}
			
			Rysunek \ref{3/PicoRadio-sound-decoding} przedstawia w jaki sposób zorganizowane zostało odtwarzanie i dekodowanie dźwięku. Wszelkie interakcje z pozostałymi komponentami systemu obsługiwane są przez rdzeń 0, natomiast rdzeń 1 obsługuje dekodowanie formatów audio. Droga, jaką obrano, pozwala na łatwe rozszerzanie obsługiwanych formatów. Ważne jest tylko, aby pojedynczy rdzeń \textit{Cortex M0+} poradził sobie z obsłużeniem dekodowania nowego formatu w czasie rzeczywistym.
			
		%	\paragraph{Flagi przerwań}
		%	Jak wcześniej wspomniano, przerwania generowane przez kanały DMA ustawiają dwie flagi \lstinline|a_done_irq| lub \lstinline|b_done_irq|. Poprzez wspólną pamięć są one odczytywane przez rdzeń 1, a ten dekoduje dane i uzupełn
		
			\paragraph{Część Decode}
				Komponenty z tej rodziny odpowiedzialne są za dostarczanie nowych danych surowych (w kodzie \lstinline|raw_buf| (\textit{raw buffer}) lub \lstinline|cbuf| (\textit{content buffer})). Klasa bazowa \lstinline|DecodeBase| odpowiada za wspólne elementy obu źródeł danych. Obsługuje ona m.in. zunifikowane funkcje do wysyłania komunikatów o zakończeniu dekodowania, zużyciu danych z bufora, bądź błędach. Umożliwione zostało także odczytywanie statystyk i metadanych. Poszczególne klasy podrzędne skupiają się na dostarczaniu danych z różnych źródeł. \lstinline|DecodeFile| odpowiada za odczyt plików z karty SD, natomiast \lstinline|DecodeStream| odbiera dane ze strumienia internetowego.
			
			\paragraph{Część Format}
				Powstały interfejs \lstinline|Format| służy do abstrakcji dekodowania danych surowych. Jego główną metodą jest \lstinline|decode_up_to_n|, która dekoduje co najwyżej \lstinline|n| jednostek danych. Aby dowiedzieć się ile jednostek należy zdekodować istnieją funkcje \lstinline|units_to_decode_whole| i \lstinline|units_to_decode_half|, zwracające odpowiednio ile jednostek zapełni cały bufor \lstinline|audio_pcm| a ile pół bufora (taka liczba jest dekodowana po otrzymaniu przerwania od DMA, którego jeden kanał transferuje pół bufora). W przypadku formatu WAV jednostki to po prostu bajty, a gdy mówimy o MP3 będą to ramki. Podklasy implementują specjalizowane funkcje do dekodowania poszczególnych formatów.
			
			\paragraph{Bufor FIFO}
				RP2040 posiada wbudowane dwa bufory FIFO do komunikacji między rdzeniami. Jeden z rdzenia 0 do rdzenia 1, drugi w przeciwnym kierunku. Wykorzystany został bufor w kierunku $1 \rightarrow 0$ do przekazywania informacji o stanie dekodowania. Zaimplementowany został moduł \lstinline|mcorefifo| do wysyłania abstrakcyjnych wiadomości. Wykorzystuje on przerwanie SIO do odbioru komunikatów, a następnie przekazuje je do zarejestrowanego odbiorcy. Jednym z takich odbiorców jest moduł odtwarzacza, który w pliku \lstinline|decodebase.cpp| odbiera komunikaty o identyfikatorze \lstinline|PLAYER| w funkcji \lstinline|player_msg()| i przekazuje do swojej głównej pętli w funkcji \lstinline|play()|.
		
		\subsubsection{Biblioteka \textit{helixmp3}}
			Do dekodowania formatu MP3 wykorzystana została biblioteka \lstinline|helixmp3|. Opiera się ona na arytmetyce stałoprzecinkowej. Oryginalnie napisana przez \textit{RealNetworks}\textsuperscript{\cite{realnetworks}} w 2003 roku, znaleziona została w internecie pod postacią repozytoria GitHub\textsuperscript{\cite{helixmp3_repo}}. Do tej biblioteki dodana została obsługa RP2040 jak również integracja ze środowiskiem CMake. Jest to pierwszy wynik w wyszukiwarce Google (fraza \textit{mp3 decoding library fixed point}), dlatego poczynione ulepszenia, zostały zgłoszone autorowi repozytorium\textsuperscript{\cite{helixmp3_pr}}. Umożliwiona została także statyczna alokacja buforów na dane dekodera.
			
			Do biblioteki dekodującej odwołuje się tylko \lstinline|FormatMP3|, który funkcją \lstinline|decode_up_to_n|, dekoduje co najwyżej \lstinline|n| ramek MP3. Zwracana jest liczba zdekodowanych ramek. Jeżeli zdekoduje ich mniej, to znaczy, że odtwarzanie zakończyło się pomyślnie (np. koniec pliku). Jeżeli zwrócona zostanie wartość mniejsza od zera, oznacza to błąd. Jeżeli danych w buforze brakuje (np. niestabilna komunikacja sieciowa), rdzeń 1 czeka na dane w nieskończoność. Użytkownik jednak w każdej chwili może przerwać oczekiwanie.
		
		\subsection{Rozpoczynanie odtwarzania}
			\imgcs{3/PicoRadio-start}{Schemat procesu rozpoczynania odtwarzania}{0.7}
			Użytkownik rozpoczyna odtwarzanie poprzez wybranie pozycji z listy ulubionych lub wyszukanie stacji/wybór pliku na karcie SD. Dowolny widok może zainicjować ekran odtwarzania \lstinline|ScPlay|. Jednym z parametrów inicjalizacyjnych jest ścieżka dostępu. Gdy nastąpi zmiana aktywnego ekranu, wywoływana jest funkcja \lstinline|player_start()|. Więcej na temat widoków i zarządzania ekranem napisano w sekcji~\ref{sec:screen}.
			
			\paragraph{Zadania systemu FreeRTOS}
				Funkcja \lstinline|player_start()| tworzy dwa osobne zadania w systemie operacyjnym, a sama kończy działanie od razu. Pierwsze z nich, \lstinline|player|, odpowiedzialne jest za uruchomienie procesu odtwarzania i przetwarzanie komunikatów (np. odnośnie konsumpcji bajtów z bufora czy wystąpienia błędów). Ładuje ono także dane do bufora z pliku. Drugie, pomocnicze zadanie \lstinline|player stat| służy do okresowego aktualizowania stanu odtwarzania na ekranie.
			
			\paragraph{Wykrywanie formatu}
				Format audio wykrywany jest na podstawie ścieżki do zasobu. Jeżeli ta zaczyna się od \lstinline|http|, zostanie użyta klasa \lstinline|DecodeStream| i \lstinline|FormatMP3|. Jeżeli początek nie dopasuje się do wzorca, przyjmowane jest odtwarzanie z pliku (klasa \lstinline|DecodeFile|) i na podstawie rozszerzenia pliku definiowane jest użycie klasy \lstinline|FormatWAV| lub \lstinline|FormatMP3|.
				
			\paragraph{Ograniczenia detekcji plików}
				Definicja formatu audio przebiega na samym początku co jest poważnym ograniczeniem i nie pozwala na zmianę formatu np. po odczytaniu nagłówka \lstinline|Content-type|. Jednak w obecnej formie projekt obsługuje tylko strumieniowanie plików MP3. Gdyby została dodana obsługa stacji AAC/AAC+ należałoby poprawić ten fragment kodu. Dodatkowo wtedy detekcja formatu plików lokalnych mogłaby zostać przeniesiona do \lstinline|DecodeFile|. Oprócz rozszerzeń, możliwa byłaby detekcja formatów plików na podstawie ich nagłówków. Pliki rozpoczynające się od \lstinline|http| zostaną potraktowane jako strumienie audio. Należy rozważyć użycie prefiksu \lstinline|file://| dla plików lokalnych.
			
			\paragraph{Możliwe błędy}
				Jeden z możliwych błędów występuje, gdy nie zostanie dopasowany żaden znany format audio. Należy wtedy zweryfikować czy pliki posiadają odpowiednie rozszerzenia, a strumienie sieciowe prefiks \lstinline|http|. Inny błąd oznacza że nie udało się rozpocząć odtwarzania, tzn. plik nie istnieje/nie można go odczytać lub serwer strumieniujący nie odpowiada lub też nie udało się określić jego adresu. Przedstawione poniżej zakańczanie odtwarzania nie uwzględnia tych błędów, ponieważ z punktu widzenia programu jeszcze się ono nie rozpoczęło.
		
		\subsection{Zatrzymywanie odtwarzania}
			\imgcs{3/PicoRadio-stop}{Schemat obsługi żądań zakończenia odtwarzania}{1}
			Zakończenie przetwarzania audio jest nietrywialnym procesem. Sygnał do zatrzymania może pochodzić z trzech różnych źródeł. Na rysunku~\ref{3/PicoRadio-stop} przedstawione zostały kolejne etapy obsługi tych sygnałów. Natomiast poniżej opisano skrótowo jak działa zgłaszanie poszczególnych kategorii zdarzeń. 
			$ $\\
			
			Parametrem funkcji \lstinline|DecodeBase::notify_playback_end(bool error)| jest flaga, która mówi, czy odtwarzanie zakończyło się błędem. Jeżeli jest ona ustawiona, to program wyświetli ekran błędu.
			
			\paragraph{Użytkownik}
				Użytkownik może zakończyć odtwarzanie poprzez naciśnięcie przycisku \textit{Wstecz} na ekranie odtwarzania. Podsystem wyświetlacza wywołuje wtedy funkcje \lstinline|player_stop()|, która rozpoczyna proces zakończenia odtwarzania i czeka aż rzeczywiście się ono zakończy. Ustawiana jest flaga \lstinline|abort|, która powoduje, że wszystkie implementacje \lstinline|decode_up_to_n(int n)|, kończą dekodowanie natychmiast. Dekodowane jest mniej ramek niż zadane \lstinline|n|, co wykrywane jest przez program jako zakończenie odtwarzania.
			
			\paragraph{Koniec pliku}
				Gdy funkcja \lstinline|load_buffer()| w \lstinline|DecodeFile| napotka koniec pliku powiadamia o tym fakcie klasę nadrzędną wywołując \lstinline|notify_eof()|. Nie używa ona bezpośrednio funkcji \lstinline|notify_playback_end()|, ponieważ przy zakończeniu odtwarzania bufor może zawierać jeszcze do 4 sekund dźwięku (bufor 64kB, format MP3 128kbps). Dopiero gdy funkcja oczekiwania na dane wykryje że jest ich za mało, a w pliku nie ma więcej bajtów do odczytania, odtwarzanie jest zakańczane. Dzieje się to w analogiczny sposób jak w przypadku zakończenia go przez użytkownika: dekodowane jest mniej ramek audio.
			
			\paragraph{Błąd}
				Błędy modułu odtwarzacza mogą być dwojakie. Błąd sieciowy występuje przy odtwarzaniu strumieni internetowych, np. radia. Biblioteka \textit{LWIP} zgłasza błąd, który poprzez \lstinline|notify_playback_end()| powoduje natychmiastowe zatrzymanie odtwarzania i wyświetlenie komunikatu o błędzie (flaga \lstinline|error| ustawiona na \lstinline|true|). Błąd odczytu z pliku występuje, gdy funkcja uzupełniająca bufor o dane z pliku zakończy się niepowodzeniem. Oznaczać to może na przykład że użytkownik usunął kartę SD z urządzenia lub wystąpił błąd komunikacji z nią. Analogicznie jak w przypadku błędu sieci odtwarzanie jest zakańczane natychmiast.
			
		\subsection{Metadane}
		Jednym z wymagań projektu było wyświetlanie aktualnie odtwarzanego utworu. Należało więc co najmniej zdekodować metadane wysyłane przez stacje radiowe. Dodatkowo, zostało zaimplementowane odczytywanie metadanych z plików MP3.
		
		\subsubsection{Stacje radiowe -- ICY}
			Szeroko stosowanym formatem przesyłania danych o utworach w strumieniach radiowych jest format ICY\textsuperscript{\cite{icy_spec}}. Klient może zażądać od serwera metadanych wysyłając do niego nagłówek \lstinline|Icy-Metadata: 1|. Serwer, jeżeli zaakceptował żądanie, odsyła nagłówek \lstinline|icy-metaint: <n>|. Jego wartość oznacza co ile bajtów strumienia będą wysyłane ramki z metadanymi. Zwykle \lstinline|<n>| jest równe 16000, co oznacza, że co każde odebrane 16000 bajtów wystąpią metadane. Jest to 1 sekunda dźwięku MP3 128kbps, czyli nazwy utworów będą aktualizowane raz na sekundę. Występuje też wartość 1000, co oznacza 16 aktualizacji w ciągu sekundy. Inne wartości są możliwe, ale nie są spotykane w praktyce.
			
			\paragraph{Abstrakcyjne położenie ramek ICY}
				Warto zaznaczyć, że miejsce wstawienia metadanych w żaden sposób nie uwzględnia formatu audio. Nie możemy zakładać że nie podzielą one jednej ramki MP3 na dwie części. Dla dźwięku MP3 128kbps ramka ma rozmiar 418 bajtów. Przy wartości \lstinline|icy-metaint| równej 16000, dane dźwiękowe będą podzielone co ok. $38.28$ ramki. Z tego powodu konieczne stało się obsługiwanie ramek ICY w momencie zapisu do bufora, zamiast przy jego odczycie. Odczyt obsługuje odpowiednia instancja \lstinline|Format|, która nie musi obsługiwać odczytywania ramek bajt po bajcie. Na przykład \lstinline|FormatMP3| nie obsługuje dekodowania ramek w częściach. Ramka MP3 musi znaleźć się w ciągłym obszarze pamięci, nie może być rozdzielona ramką ICY.
			$ $\\
			
			Funkcja \lstinline|DecodeStream::play()|, jeżeli dostępny jest nagłówek \lstinline|icy-metaint|, inicjalizuje odbierane danych metodą \lstinline|ICY::start()|. Następnie rejestruje odwołanie, które jest wywoływane po każdym zapisie do bufora oraz przetwarza już odebrane dane. W trakcie tych czynności blokowany jest kontekst biblioteki sieciowej, aby w trakcie przetwarzania danych nie zostały odebrane żadne nowe dane, a po odblokowaniu każde następne były wychwycone przez funkcję \lstinline|cbuf_write_cb()|.
			
			W każdym z tych scenariuszy (wstępne i późniejsze przetwarzanie) wywoływana jest w pętli funkcja \lstinline|ICY::read()|. Pętla jest potrzebna, ponieważ w porcji odebranych danych, szczególnie dla niskich wartości \lstinline|icy-metaint|, może wystąpić więcej niż jedna ramka ICY.
			
			\imgcs{3/PicoRadio-icy}{Ramka MP3 rozdzielona ramką ICY}{0.9}
			\paragraph{Format danych ICY}
				Nagłówek metadanych ICY składa się z jednego bajtu kodującego rozmiar danych (bez nagłówka) podzielony przez 16. Dane dopełniane są zerami do podanego rozmiaru. Wewnątrz ramki kolejne pola oddzielone są od siebie średnikami, a same pola są w formacie \lstinline|klucz='wartosc'|. Dekoder zaimplementowany w projekcie obsługuje tylko klucz \lstinline|StreamTitle|, którego wartość to zazwyczaj tytuł utworu i jego wykonawca. Ramka ICY została przedstawiona na rysunku~\ref{3/PicoRadio-icy}.
				$ $\\
				
			Wywołanie \lstinline|ICY::read()| kopiuje ramkę ICY z bufora audio do bufora tymczasowego, a następnie przesuwa dane za ramką wstecz o rozmiar ramki. Operację można porównać do wycinania tekstu z dokumentu tekstowego. W ten sposób przywracamy ciągłość ramce MP3. Dane w buforze tymczasowym nie są interpretowane aby zaoszczędzić cenny czas. Przypomnijmy, cała ta operacja odbywa się przy zablokowanej komunikacji sieciowej. Dane interpretowane są dopiero gdy zadanie \lstinline|player stat| wywoła \lstinline|DecodeBase::get_meta_str()|, która w implementacji \lstinline|DecodeStream| odwołuje się do metody \lstinline|ICY::get_stream_title()|. Funkcja ta blokuje mutex bufora tymczasowego i kopiuje dane do swojego buforu na stosie. Dopiero wtedy rozpoczyna potencjalnie kosztowną czasowo interpretację danych.
		
		\subsubsection{Lokalne pliki MP3 -- ID3v2}
			Tagowanie MP3 obsługiwane jest zupełnie różnie od ramek ICY. Mogą one występować na początku plików MP3. Sygnalizuje to fakt, że pliki te rozpoczynają się 3 bajtami równymi \lstinline|ID3|. Funkcje do obsługi tego typu tagowań zostały zaimplementowane w klasach pochodnych \lstinline|Format|. Wykorzystana została już wcześniej istniejąca funkcja \lstinline|Format::decode_header()|. Obsługiwała ona dekodowanie nagłówków WAVE. Wywoływana jest ona po pierwszym załadowaniu bufora, tylko raz na dany plik/strumień. Implementacja \lstinline|FormatMP3| wywołuje wtedy funkcję \lstinline|ID3::try_parse()|.
			
			\paragraph{Standard ID3v2}
			Ramki ID3 w wersji drugiej mają znacznie bardziej rozbudowane kodowanie od np. ramek ICY czy starszego formatu ID3v1. Dokumentacja oryginalnie dostępna była pod adresem \href{id3.org}{id3.org} lecz w trakcie pisania pracy była ona niedostępna. Skorzystano z alternatywnej strony\textsuperscript{\cite{id3_spec_mutagen}}.
			
			\paragraph{Format ramek}
			\imgcs{3/PicoRadio-id3}{Format danych ID3v2}{0.8}
			Budowa formatu ID3v2 została przedstawiona na rysunku~\ref{3/PicoRadio-id3}. Podstawową jednostką budowy są tagi. Może być ich w pliku dowolna liczba. Są one opakowane dodatkowymi informacjami, takimi jak np. nagłówki. Z głównego nagłówka pobierany jest rozmiar i flaga czy nagłówek rozszerzony jest obecny. Jeżeli tak, to jest on ignorowany. Padding i stopka również są ignorowane.
			$ $\\
			
			Parser rozpoznaje ramki o kodach \lstinline|TPE1|(artysta) i \lstinline|TIT2|(tytuł). Są to ramki tekstowe, dlatego wyszczególniono taki format ramek na rysunku. Pierwszy bajt oznacza jakie kodowanie wykorzystano do zapisania tekstu. Możliwe formaty to ISO-8859-1, UTF-16, UTF-16BE i UTF-8. Wszystkie zostały zaimplementowane i przetestowane.
	
	\section{Bufor kołowy}
		\label{sec:circular_buffer}
		\imgcs{3/PicoRadio-buffer}{Schemat wykorzystania bufora kołowego}{0.8}
		Małym, lecz kluczowym modułem w projekcie jest bufor kołowy \lstinline|CircularBuffer|. Używany jest on przede wszystkim przy odtwarzaniu dźwięku. Schematyczne wykorzystanie przedstawiono na rysunku~\ref{3/PicoRadio-buffer}. Poniżej zostały opisane najważniejsze jego funkcje.
		
		\paragraph{Zapis i odczyt danych przez różne wątki}
			Dzięki zastosowaniu osobnych liczników do zapisu i odczytu danych, nie występuje problem wyścigu. Każda operacja może być wykonywana niezależnie przez co najwyżej jeden wątek.
			
		\paragraph{Funkcje zgłaszające}
			Moduł umożliwia zarejestrowanie funkcji, które zostaną wywołane po odczytaniu lub zapisaniu danych. Wykorzystywane są np. do potwierdzenia odbioru w komunikacji sieciowej lub do wycięcia metadanych ICY.
		
		\paragraph{Sprawdzanie stanu zapełnienia i czekanie}
			Udostępniony jest szereg funkcji określających stan bufora. Można odczytać pozycje odczytu/zapisu bezpośrednio, lecz poza procesem tworzenia oprogramowania, nie jest to przydatna metryka, ponieważ bufor "zapętla się". Istotniejszą metryką jest natomiast to, ile danych zostało zapisane do bufora a ile odczytane od początku komunikacji. Dzięki tym danym możliwe jest jednoznaczne określenie, ile danych jest gotowych do odczytania w danej chwili, oraz ile jest to procent całkowitej pojemności bufora.
		
		\paragraph{Zapętlanie}
			Najważniejszą funkcją bufora jest jego zapętlanie. Problem pojawił się w chwili implementacji dekodera MP3, ponieważ rozmiar bufora nie dzielił się całkowicie przez długość ramki. To znaczy, ostatnia ramka w buforze była nieciągła. Pierwsza część mogła znaleźć się na końcu bufora, a druga na jego początku. Problem rozwiązano poprzez dołożenie przed początkiem kilku kilobajtów pamięci, do której kopiowane są nieciągłe dane. Wskaźnik odczytu staje się wtedy ujemny. Poszczególne sekcje bufora zostały również pokazane na rysunku~\ref{3/PicoRadio-buffer}. Część normalna \lstinline|buffer| rozpoczyna się zerowym wskaźnikiem odczytu \lstinline|read_at|. Część ukryta \lstinline|buffer_hidden| znajduje się bezpośrednio przed nią.
		
		\paragraph{Wycinanie zapisanych danych}
			Implementacja wycinania stała się konieczna w momencie kiedy w środku niepodzielnej jednostki przy odczycie (np. ramki MP3) pojawiają się metadane jak np. ICY. Trzeba je wtedy przetworzyć i usunąć, zapełniając powstałą lukę danymi występującymi dalej w buforze.
	
	\section{Klient protokołu HTTP}
		Potrzeba stworzenia własnej implementacji klienta HTTP stała się konieczna, aby zintegrować go z buforem kołowym i biblioteką sieciową. Obsługuje on przekierowania i podstawowe nagłówki. Wystarczająco, aby z powodzeniem pobierać wyniki wyszukiwań stacji oraz odtwarzać je. Implementacja jest dwuczęściowa. Nadrzędny moduł \lstinline|HttpClient| obsługuje wysokopoziomowy standard HTTP. Zajmuje się komponowaniem żądań, ich nagłówków, a także przetwarzaniem odpowiedzi. Podrzędny moduł obsługuje niskopoziomową komunikację sieciową. Taka budowa modułowa pozwoliła na testowanie klienta w środowisku PC ze stosowną implementacją modułu podrzędnego. Urządzenie zawiera moduł \lstinline|HttpClientPico|, który współpracuje z zasobami dostępnymi na mikrokontrolerze.
		$ $\\
		
		Obsługiwane nagłówki są ograniczone z uwagi na chęć statycznej alokacji pamięci. Żądanie wysyłane jest z nagłówkami:
		\begin{itemize}
			\item \lstinline|Host| o wartości hosta z którego pobierane są dane,
			\item \lstinline|User-agent: PicoRadio/0.1|,
			\item \lstinline|Icy-MetaData| o wartości \lstinline|1|, jeżeli program ustawił odpowiednią flagę.
		\end{itemize}
		Natomiast przetwarzane są następujące nagłówki odpowiedzi:
		\begin{itemize}
			\item \lstinline|Location| -- wykorzystywane przy przekierowaniach,
			\item \lstinline|Content-Type| -- typ treści, używane głownie przy przetwarzaniu wyników wyszukiwania,
			\item \lstinline|Content-Length| -- długość treści, j.w.
			\item \lstinline|Icy-Metaint| -- używane przy przetwarzaniu metadanych ICY.
		\end{itemize}
		
		Niestety brak jest obsługi szyfrowania. Środowisko zawiera implementację TLS, lecz nie została ona wykorzystana z uwagi na prawdopodobnie niewystarczającą moc obliczeniową mikrokontrolera. Wiele stacji transmituje z użyciem protokołu HTTP, tylko niewielka część z nich wymuszała przekierowania na szyfrowaną transmisję. Klient musi je obsługiwać ponieważ wiele stacji wykorzystuje je do geolokalizacji serwera transmitującego. W konfiguracji zawarta została opcja \lstinline|HTTP_MAX_REDIRECTS| (domyślnie 2), która mówi, ile razy maksymalnie przekierowań chcemy obsłużyć. Zwykle jeżeli jest to więcej niż jedno, serwer próbuje wymusić transmisję szyfrowaną.
		
	\section{Dane}
		Główną jednostką informacji w projekcie jest stacja radiowa. Na potrzeby unifikacji dostępu do danych o stacjach powstał interfejs \lstinline|DataSource|. Zawiera on dwie metody:
		\begin{itemize}
			\item \lstinline|read_char()| -- odczytuje znak,
			\item \lstinline|more_content()| -- zwraca czy w źródle jest więcej danych.
		\end{itemize}
		Nad metodą czytającą znak po znaku zaimplementowana została metoda \lstinline|read_line()| czytająca linia po linii. Obsługuje ona zakończenia linii \lstinline|\n| oraz \lstinline|\r\n|. Wykorzystywana jest ona przez moduł list oraz, aby uniknąć duplikacji kodu, przez klienta HTTP do przetwarzania odpowiedzi.
		
		\subsection{Listy}
			Listy implementują wczytywanie różnych formatów. Przechowują także wskaźniki na bufory danych, które są wspólne dla każdej implementacji. Klasa \lstinline|List| jest klasą nadrzędną. Odczytuje ona źródło danych linia po linii, a następnie przekazuje do funkcji \lstinline|List::consume_line_format()| której implementacja zawarta jest w podklasach opisanych poniżej. Dokonuje ona właściwej interpretacji formatu.
			
			\paragraph{Statyczna alokacja} Wszystkie klasy list są tworzone statycznie i współdzielą pamięć wpisów. Jest to bardzo istotnie w środowisku o ograniczonej pamięci operacyjnej. Zazwyczaj ładowanie jednego typu wyników nie koliduje z pozostałymi, a jeżeli tak się dzieje to resetowany jest stan programu ładującego który przy następnym użyciu musi przeładować dane listy, bo zostały one nadpisane. Z tego też powodu modyfikowanie listy ulubionych odbywa się bezpośrednio w pamięci stałej, bez ładowania całej listy stacji. Statyczna alokacja ma też swoje pozytywne strony, mianowicie przechowywany jest stan list. Po powrocie z wybranej stacji do wyników ładowania (do listy ulubionych lub wyszukiwania) nie ma potrzeby od nowa ładować danych.
			
			\subsubsection{Format M3U}
				Jednym z formatów obsługiwanych przez projekt jest format M3U\textsuperscript{\cite{m3u}} w wersji \textit{Extended}. Format ten został wybrany z uwagi na jego prostotę budowy oraz to, że strony agregujące stacje radiowe go obsługują. Jest to popularny format zapisu list odtwarzania. W wersji standardowej przybiera postać linków do plików/strumieni zapisanych w osobnych liniach pliku tekstowego. Wersja rozszerzona wprowadza specjalne komentarze. Zaimplementowany interpreter obsługuje komentarz \lstinline|EXTINF|, który zawiera czas trwania ścieżki oraz jej nazwę.
			
			\subsubsection{Format PLS}
				Niektóre stacje radiowe przed wysłaniem strumienia audio, wysyłają plik w formacie PLS\textsuperscript{\cite{pls}}. Plik taki zawiera różne warianty tego samego strumienia w celu równoważenia obciążenia. Po wykryciu tego formatu ładowane są pierwsze 2 stacje (konfigurowalne) i wybierana jest losowa z nich. Format składa się z par deklaracji postaci \lstinline|FileX| i \lstinline|TitleX|, gdzie \lstinline|X| to kolejne liczby naturalne.
			
		% TODO \subsection{Wpis na liście}
		% TODO \subsection{Pliki pomocnicze}
			
		\subsection{Klasy ładujące}
			Wczytywanie list z konkretnych źródeł danych implementowane jest przez podklasy klasy \lstinline|Loader|. Prezentuje ona spójny interfejs do ładowania danych. Metody \lstinline|load()| oraz \lstinline|load_abort()| umożliwiają zarządzanie tym procesem. Tworzone jest zadanie systemowe, które wykonuje potrzebne kroki bez blokowania interfejsu użytkownika. Funkcje \lstinline|get_entry_count()| oraz \lstinline|get_entry()| pozwalają na pobieranie informacji o wynikach. Klasa obsługuje także paginację wyników. Podklasy mogą definiować własne funkcje \lstinline|begin()|, które pełnią rolę konstruktora obiektu (przekazują niezbędne parametry, ale bez dynamicznej alokacji pamięci). Mogą one wymagać podania ścieżki lub np. słowa kluczowego do wyszukania.
			
			\subsubsection{Wyniki wyszukiwania}
				Pierwszą implementacją klasy ładującej była klasa służąca do wczytania wyników wyszukiwania stacji \lstinline|LoaderSearch|. Poprzez metodę \lstinline|begin(query)| przekazywana jest jej fraza do wyszukania. Następnie następuje odwołanie do klienta HTTP, który implementuje interfejs \lstinline|DataSource|. Agregat stacji radiowych zwraca dane wraz z nagłówkiem \lstinline|Content-Type|. Jego wartość determinuje, która lista zostanie użyta do interpretacji. Typ \lstinline|audio/mpegurl| oznacza \lstinline|ListM3U|, natomiast \lstinline|audio/scpls| lub \lstinline|audio/x-scpls| implikuje wykorzystanie \lstinline|ListPLS|. Tak załadowana lista stacji jest dostępna dla reszty systemu poprzez metody klasy nadrzędnej \lstinline|Loader|.
			
			\subsubsection{Ulubione stacji}
				Z uwagi na gotową implementację formatu M3U, zdecydowano się na wykorzystane go do przechowywania listy ulubionych stacji. Prostota formy oznaczała że możliwe będzie dodawanie wpisów w miejscu bez konieczności ładowania całego pliku do pamięci. Kolejną zaletą jest fakt, że pliki \lstinline|.m3u| to pliki tekstowe. Przewidziano możliwość zaimplementowania funkcji eksportowania i importowania listy ulubionych na kartę SD. Użytkownik mógłby modyfikować plik we własnym zakresie dodając stacje niebędące w ogólnodostępnym spisie stacji. Na ten moment nie zostało to zaimplementowane.

			\subsubsection{Znane sieci Wi-Fi}
				Tutaj także zostały wykorzystane pliki w formacie M3U. Nazwa sieci przechowywana jest jako nazwa stacji, a pole \lstinline|url| wykorzystano na przechowywanie hasła. Lista ta, razem z listą ulubionych stacji używa klasy bazowej \lstinline|LoaderM3U|. Dzięki temu implementacja interpretacji formatu jest jedna. Wczytywanie listy następuje w ekranie ustawień, jak i po uruchomieniu urządzenia, w celu automatycznego połączenia z najlepszą siecią.
				
			\subsubsection{Wykryte sieci Wi-Fi}
				Do skanowania pobliskich sieci została stworzona implementacja \lstinline|LoaderWifiScan|. Uruchamia ona skanowanie sieci przy pomocy wbudowanego w środowisko \lstinline|pico-sdk| sterownika układu Wi-Fi. Zwracane sieci są w losowej kolejności, często zduplikowane. Aby temu zaradzić, jak i obsłużyć stronicowane wyników, stworzona została klasa \lstinline|LFSorter|, opisana poniżej.
				
			\subsubsection{Pliki lokalne}
				Interfejs list i klas ładujących okazał się także przydatny przy ładowaniu listy lokalnych plików z karty SD. Klasa \lstinline|LoaderLocal| wykorzystuje referencję do klasy \lstinline|Path|, która implementuje również metody poruszania się po strukturze folderów. Metoda \lstinline|go()| powoduje zejście w dół struktury drzewiastej, natomiast \lstinline|up()| umożliwia przejście poziom wyżej. Metody obsługi systemu plików zwracają listingi katalogów w kolejności dodawania plików do niego. Porządek alfabetyczny, jak i priorytet folderów został osiągnięty przy wykorzystaniu klasy \lstinline|LFSorter|.
				
			\subsubsection{Stałe wyniki}
				Bardzo prosta klasa ładująca, przepisuje ona jedynie wyniki z pamięci stałej do listy wyników. Używana przez ekran ustawień.
				
%		\paragraph{Karta SD -- FatFS}
		\subsection{Pamięć Flash -- LittleFS}
			Aby lista ulubionych stacji czy lista zapisanych sieci Wi-Fi były przechowywane pomiędzy wyłączeniami urządzenia, musiały one być zapisane w pamięci nieulotnej. Mikrokontroler RP2040 przechowuje program w zewnętrznej pamięci typu \textit{flash}. Na płytkach Pi Pico dostarczone zostały układy o rozmiarach 2MB. Środowisko programistyczne umożliwia, oprócz oczywistej operacji odczytu, także zapis do tej pamięci. Wykorzystano tą właściwość do umieszczenia w końcowych 64KB systemu plików LittleFS\textsuperscript{\cite{littlefs}}, specjalnie stworzonego do przechowywania danych w środowiskach wbudowanych i pamięciach typu \textit{flash}. Stworzona została klasa \lstinline|LFSAccess|, która dostarcza podstawowe metody do manipulacji tekstami, jak również implementuje interfejs \lstinline|DataSource|.
			
		\subsection{Sortowanie -- LFSorter}
			Niektóre metody zwracają wyniki w postaci strumienia kolejnych wyników, bez możliwości indeksacji indywidualnych pozycji. Z powodu ograniczonej pamięci RAM, nie jest możliwe wczytanie wszystkich wyników i wybranie z nich kilku w zadanej kolejności. Ten problem rozwiązuje klasa \lstinline|LFSorter|, która zapisuje cały strumień do pamięci stałej \textit{flash} (przy użyciu \lstinline|LFSAccess|). Następnie, przy użyciu metody \lstinline|get_smallest_n_skip_k(n, k)|, pozwala wczytać elementy $k,\; k+1,\; ...,\; k+n-1$ z ciągu posortowanych elementów (indeksowanie od 0, sortowanie wg dostarczonej funkcji porównującej). Ciąg ten nie jest nigdzie zapisywany.
			
			\paragraph{Pamięć podręczna}
			Plik tymczasowy utworzony podczas procesu ładowania strumienia, może zostać wykorzystany w kolejnych wywołaniach. Np. z każdą nową stroną nie ma potrzeby skanować od nowa dostępnych sieci Wi-Fi czy ładować listingu lokalnego katalogu.
						
			\paragraph{Złożoność obliczeniowa}
			Wewnętrznie implementowany jest algorytm sortowania przez wybieranie, który ignoruje pierwsze $k$ elementów, a następnie zwraca kolejne $n$ elementów. Np. przy ładowaniu pierwszej strony wyników $k$ będzie równe 0. Liczba $n$ jest stała i równa maksymalnej liczbie elementów na jednej stronie. Jeżeli założymy, że liczba elementów w całym strumieniu będzie rzędu $k+n$ (np. ładujemy ostatnią stronę) to złożoność obliczeniowa algorytmu to $O((k+n)^2)$. Nie jest to efektywny algorytm, jednak pozwala maksymalnie zaoszczędzić pamięć RAM, gdyż jej użycie nie zależy od liczby wszystkich elementów.
			

		\subsection{Współpraca klas ze sobą}
			\imgh{3/PicoRadio-loaders}{Współpraca list z klasami ładującymi i ekranami}{0.95}
			Na rysunku~\ref{3/PicoRadio-loaders} przedstawiono współpracę poszczególnych klas. Klasy ładujące mogą wykorzystywać listy. Jeżeli to robią, ich źródło danych musi implementować interfejs \lstinline|DataSource|. Tak się dzieje w przypadku klas \lstinline|LoaderM3U| oraz \lstinline|LoaderSearch|. Ładują one dane odpowiednio z pamięci stałej oraz z Internetu. Interpretacja zachodzi przy użyciu odpowiednich list. Odmienna sytuacja ma miejsce w przypadku pozostałych klas. Nie interpretują one plików/strumieni, więc nie potrzebują być implementacjami \lstinline|DataSource|, ani używać list. Interfejsy do skanowania Wi-Fi i ładowania plików lokalnych zwracają nazwy kolejnych elementów bezpośrednio, bez konieczności interpretacji. Jednak są one losowe i wymagają posortowania przy wykorzystaniu \lstinline|LFSSorter|. Klasa \lstinline|LoaderConst| bezpośrednio przepisuje wyniki i jest najprostszą ze wszystkich. Służy do definiowania list o stałej zawartości.
			
			\paragraph{Ekrany}
				Istnieje powiązanie pomiędzy klasami ładującymi a ekranami. Każdej klasie ładującej przyporządkowany jest ekran, który wyświetla dane pozycje. Zawiera on w sobie referencję klasy ładującej. Przekazuje ją swojej klasie nadrzędnej jako wskaźnik do klasy ogólnej \lstinline|Loader|. Tym sposobem, każdy z ekranów może ustalać szczegółowe parametry ładowania, a ekran nadrzędny implementuje ogólne funkcje związane z wyświetlaniem załadowanych pozycji na ekranie.
	
	\section{Ekran}
		\label{sec:screen}
		Z uwagi na założenie miniaturyzacji urządzenia wybrany został relatywnie mały ekran. Urządzenie firmy Adafruit zawiera wyświetlacz ciekłokrystaliczny (\textit{LCD}) o przekątnej 1.8 cala oraz sterownik ST7735S obsługiwany poprzez protokół SPI. Na ekranie znajdowała się folia z zieloną zakładką. Jest to istotne ponieważ na rynku występują także wersje oznaczone kolorem czerwonym, posiadające inne opcje programowania.
		$ $\\
		
		\noindent
		Moduł wyświetlacza został podzielony na następujące podmoduły:
		\begin{itemize}
			\item \lstinline|tft| -- niskopoziomowa obsługa komunikacji i rysowania,
			\item \lstinline|assets| -- zasoby do wyświetlania ikon i czcionek,
			\item \lstinline|screens| -- ekrany użytkownika
			\begin{itemize}
				\item \lstinline|wifi| -- ekrany Wi-Fi
			\end{itemize}
			\item \lstinline|screenvirt| -- ekrany wirtualne.
		\end{itemize}
		
		\subsection{Komunikacja niskopoziomowa}
			Kod niskopoziomowej komunikacji ze sterownikiem ekranu zawiera folder \lstinline|display/tft|. Inicjalizacja zapożyczona została z biblioteki firmy Adafruit. W pliku \lstinline|st7735_init.h| znajdują się definicje komend oraz listy poleceń potrzebne do uruchomienia wyświetlacza. Klasa \lstinline|ST7735S| zawiera metody \lstinline|reset()|, \lstinline|write_command_list()| oraz \lstinline|module_init()|, które odpowiadają za ustawienie poprawnych parametrów pracy urządzenia. Wszystkie wymagane operacje, włącznie z konfiguracją pinów mikrokontrolera, zawiera metoda \lstinline|ST7735S::init()|.
			
		\paragraph{Kolory}
			Do każdej funkcji przekazywany jest kolor w formacie 24 bitowego RGB, tj. po 8 bitów na kolor, w postaci jednej liczby. Kolor ten jest automatycznie mapowany na wewnętrzną 16 bitową reprezentację obsługiwaną przez sterownik. Podział na składowe RGB w tej postaci to:
			\begin{itemize}
				\item 5 bitów -- kolor czerwony (najstarsze),
				\item 6 bitów -- kolor zielony,
				\item 5 bitów -- kolor niebieski.
			\end{itemize}
		
		\imgh{3/PicoRadio-screen-xy}{Układ współrzędnych na ekranie}{0.45}
		\paragraph{Współrzędne}
			Na rysunku~\ref{3/PicoRadio-screen-xy} przedstawiono sposób, w jaki na ekranie reprezentowane są współrzędne. Na magistralę szeregową dane wysyłane są linia po linii.
		
		\subsection{Rysowanie}
			Aby przesłać kolory dla wybranych pikseli na ekranie, należy ustawić odpowiednie zmienne wskaźnikowe wewnątrz sterownika wyświetlacza. Funkcja \lstinline|ST7735S::setup_write()| pozwala na ich ustawienie i przekazanie początkowych oraz końcowych wartości współrzędnych. Dzięki temu na ekranie tworzony jest prostokąt dla którego należy przesłać zaktualizowane wartości pikseli w formacie podanym powyżej. Jednak oprócz funkcji do obsługi niskopoziomowej komunikacji klasa \lstinline|ST7735S|  wspiera także rysowanie prostokątów, czcionek i ikon.
			
			\subsubsection{Prostokąty}
				\imgh{3/PicoRadio-screen-rect}{Współrzędne prostokąta na ekranie}{0.6}
				Prostokąty rysowane są poprzez funkcję \lstinline|fill_rect(x, y, w, h, bg)|, gdzie:
				\begin{itemize}
					\item \lstinline|x| -- współrzędna kolumny ,
					\item \lstinline|y| -- współrzędna wiersza,
					\item \lstinline|w| -- szerokość,
					\item \lstinline|h| -- wysokość,
					\item \lstinline|bg| -- kolor tła (24 bitowe RGB).
				\end{itemize}
			
			\subsubsection{Czcionki}
				Każda czcionka składa się z dwóch tablic \lstinline|ascii_data_H| i \lstinline|utf8_data_H|, gdzie \lstinline|H| to rozmiar czcionki, tj. wysokość w pikselach (szerokość jest połową wysokości). Zostały one opisane strukturą \lstinline|font| w pliku \lstinline|assets/font.hpp|.
				
				\paragraph{Mapowanie}
					Pierwsza tablica zawiera znaki od spacji (kod \lstinline|0x20| ASCII) do tyldy (kod \lstinline|0x7E|). Druga z tablic zapewnia wyświetlanie znaków Unicode. Mapowanie jest tu arbitralne zapewnione funkcją sprawdzającą wartości 2-3 kolejnych bajtów danych. Zawiera ona obecnie 18 polskich znaków (wariant duży i mały) jak również symbol nieskończoności. Istnieje możliwość dodawania dowolnej liczby nowych znaków.
				
				\imgh{3/PicoRadio-screen-font}{Kodowanie czcionek (wartości 0x00 zastąpiono pustymi znakami)}{0.6}
				\paragraph{Kodowanie}
					Czcionki kodowane są jako bitmapy. Każda z tablic zawiera tyle elementów, ile jest pikseli we wszystkich znakach czcionki w tej tablicy. Każda wartość to jasność piksela (255 -- kolor pierwszoplanowy, 0 -- kolor tła). Dla przykładu czcionka podstawowa ASCII zawierająca 95 znaków o wymiarach 24x12 pikseli będzie miała rozmiar 27360 bajtów. Dodając 19 znaków Unicode otrzymujemy 32832 bajtów. Kodowanie znaku \lstinline|A| z tej czcionki przedstawia rysunek~\ref{3/PicoRadio-screen-font}.
				
				$ $\\
				W projekcie została wykorzystana czcionka Ubuntu\textsuperscript{\cite{ubuntu_font}} w wersji Mono (stała szerokość każdego znaku). Stworzony skrypt w języku Python wygenerował potrzebne bitmapy do projektu. Dostępne rozmiary czcionki to 12 (rozmiar ok. 8kB), 16 (ok. 14kB) i 24 (ok. 32kB). Razem stanowi to 54kB, czyli 2.65\% pamięci ROM. Czcionka została zapisana w pliku \lstinline|assets/ubuntu_mono.cpp| a także utworzono funkcję dostępową \lstinline|ubuntu_font_get_size()|. 
				
			\subsubsection{Ikony}
				Ikony kodowane są w podobny sposób do czcionek. Różnią się tym, że każda ikona może mieć inny rozmiar i jest kodowana swoją własną tablicą. W projekcie znalazły się m.in. ikony:
				\begin{itemize}
					\item \lstinline|icon_backspace| -- 15x15, ikona usuwania tekstu,
					\item \lstinline|icon_back| -- 11x11, ikona wstecz,
					\item \lstinline|icon_fav_back| -- 15x16, ikona powrotu do listy ulubionych.
				\end{itemize}
		
		\subsection{Ekrany}
			\imgh{3/PicoRadio-screens}{Hierarchia ekranów}{0.55} % TODO opisać te ekrany na rysunku np ScPlay -- odtwarzacz
			Na rysunku \ref{3/PicoRadio-screens} przedstawiono hierarchię ekranów. Klasą nadrzędną wszystkich ekranów jest klasa \lstinline|Screen|. Implementuje ona podstawową siatkę przycisków, przechodzenie pomiędzy nimi, jak również rysowanie i aktualizację ruchomych tekstów. Bezpośrednimi potomkami tej klasy są ekrany o niestandardowym układzie (np. ekran odtwarzania). Jednak większość ekranów jest podklasami dwóch innych potomnych klas: \lstinline|ScreenList| i \lstinline|ScreenKb|. Są to klasy wirtualne (znajdują się w katalogu \lstinline|screenvirt|), niemogące istnieć bezpośrednio. Standaryzują one układ potomnych ekranów. Pierwsza z nich implementuje widok listy, a druga, widok klawiatury. \lstinline|ScreenKb| implementowana jest przez ekran wyszukiwania stacji i ekran wprowadzania hasła Wi-Fi.
			
		\subsection{Menedżer ekranów}
			Ekranami użytkownika zarządza plik \lstinline|screenmng.cpp|. Tworzy on szereg konstrukcji wymaganych do poprawnego obsłużenia interfejsu użytkownika. Poniżej zostały opisane wybrane z nich.
			
			\paragraph{Semafory}
				Aby zabezpieczyć dostęp do medium szeregowego, utworzony został semafor binarny \lstinline|mutex_display|. Zapewnia on ciągłość operacji przesyłu danych. Musi ona wystąpić ponieważ w sterowniku został wybrany prostokąt, którego kolory będą aktualizowane. Dodatkowo powstał \lstinline|mutex_ticker|, który zabezpiecza funkcję aktualizacji ekranów. Zadanie \lstinline|scr tick| jest wywoływane co 50ms i aktualizuje np. położenie ruchomych tekstów na ekranie.
				
			\paragraph{Instancje klas}
				W pliku zdefiniowano także instancje najważniejszych klas. Zdefiniowana jest instancja klasy \lstinline|ST7735S| oraz klas ładujących \lstinline|LoaderSearch|, \lstinline|LoaderFav| i \lstinline|LoaderLocal|. Statyczna definicja pozwala na analizę zużycia pamięci w trakcie kompilacji programu oraz chroni przed niedeterministyczną operacją rezerwowania pamięci w czasie działania programu.
				
			\paragraph{Obsługa ekranów użytkownika}
				Poszczególne ekrany użytkowników także zostały tutaj zainstancjonowane. Plik nagłówkowy \lstinline|screenmng.hpp| eksportuje te definicje, aby ekrany mogły ustawiać parametry innych ekranów, które otwierają. Znalazły się tutaj także funkcje do zmiany aktualnie wyświetlanego ekranu. Domyślnie zmiana ta odbywa się poprzez funkcję \lstinline|screenmng_input()|, do której przekazywane są naciśnięcia przycisków. Klasa bazowa wszystkich ekranów zawiera metodę \lstinline|Screen::input()|, która może zwrócić wskaźnik do ekranu, który ma zostać otworzony jako następny. Jest ona wywoływana przez funkcję zarządcy i jeżeli zwróci niezerowy wskaźnik to otwierany jest nowy ekran. Jednak w trakcie rozwoju oprogramowania, konieczne stało się zdefiniowanie funkcji \lstinline|screenmng_open()|, która może arbitralnie zmieniać otwarty ekran. Jest to używane np. przy zakończeniu odtwarzania. Wskaźnik \lstinline|current_screen| ustawiany jest zawsze na aktualnie otwarty ekran. Jest to użyteczne przy funkcji aktualizacji ekranu.

	\section{Wejście}
		\noindent
		Zawartość modułu znajduje się w 3 katalogach:
		\begin{itemize}
			\item \lstinline|buttons| -- Przyciski, interakcja z użytkownikiem,
			\item \lstinline|sd| -- Wykrywanie karty SD,
			\item \lstinline|analog| -- Odczyt poziomu naładowania baterii.
		\end{itemize}
		
		Katalogi te zawierają po 2 pliki (nagłówkowy i kod źródłowy) realizujące funkcje opisane poniżej.
		
		\subsection{Interakcje użytkownika}
			Dane od użytkownika pobierane są za pomocą przycisków. Każdy z nich dołączony jest bezpośrednio do mikrokontrolera. Naciśnięcie przycisku powoduje wywołanie zbocza opadającego. Wykryte przez układ, aktywuje ono przerwanie. Eliminacja drgań styków została osiągnięta poprzez zastosowanie zewnętrznych kondensatorów i wbudowanych przerzutników Schmitta dostępnych na każdym wejściu RP2040, oraz poprzez odczekanie 20ms po wywołaniu przerwania i ponownym sprawdzeniu stanu na wejściu. Przerwanie, zgodnie z dobrymi praktykami, ustawia jedynie odpowiednie flagi, które zostały opisane poniżej.
			
			\paragraph{Przekazywanie danych}
				Podsystem przycisków opiera się o dwie tablice zawierające odpowiednie dane dla każdego przycisku z osobna. Pierwsza z nich, o nazwie \lstinline|b_pressed[]|, zawiera wartości logiczne. Mówią one o tym czy przycisk jest w danej chwili wciśnięty czy nie. Druga, \lstinline|b_pressed_time_us[]|, zawiera informację, w której mikrosekundzie nastąpiło wciśnięcie przycisku. Używa ona wbudowanej funkcji \lstinline|time_us_32()| do pobierania czasu.
			
			\imgh{3/PicoRadio-buttons}{Maszyna stanów w module przycisków}{0.75}
			
			Przerwanie, oprócz ustawienia odpowiednich wartości w tablicach, wybudza zadanie \lstinline|input handle|. Zawiera ono maszynę stanów, która umożliwia, oprócz podstawowego przekazywania zdarzeń do interfejsu, powtarzanie naciśnięć, tak jak robią to klawiatury komputerowe. Dodatkowo zawarto w niej także obsługę wygaszania ekranu. Na rysunku~\ref{3/PicoRadio-buttons} przedstawiono jej funkcjonowanie.
			
			\paragraph{Czas oczekiwania}
				Czas oczekiwania na ponowne uruchomienie maszyny jest tym mniejszy im częściej dane zdarzenie może wystąpić. To znaczy, gdy żaden z przycisków nie jest naciśnięty, a ekran wygaszony, maszyna oczekuje w nieskończoność na sygnał z przerwania. Gdy ekran nie jest wygaszony, zadanie czeka co najwyżej 30s. Po tym czasie następuje sprawdzenie warunków do wygaszenia, np. czy odtwarzanie jest uruchomione (pominięte na rysunku). Gdy są one spełnione, ekran zostaje wygaszony. Kiedy użytkownik kliknął i przytrzymuje przycisk, zadanie wykonuje się 26 razy na sekundę. Zapewnia to wystarczająco dokładny pomiar czasu, a nie obciąża zbytnio procesora. Jeżeli stan wejścia jest niski po minimum 20ms wykonywana jest jednokrotna akcja. Rozpoczęcie powtarzania następuje po 500ms ciągłego naciskania. Wartość 26 definiuje prędkość powtarzania znaków. Jest to częstotliwość powtarzania znaków przez klawiatury komputerowe. Wszystkie czasy są konfigurowalne w momencie kompilacji programu.
		
		\subsection{Karta SD}
			Pin \textit{Card Detect} slotu na karty SD również został bezpośrednio podłączony do mikrokontrolera i działa zgodnie z tymi samymi zasadami co piny przycisków. Jednak obsługa wykrywania karty jest znacznie prostsza. Zadanie \lstinline|sd| wykrywa zmianę stanu na odpowiednim pinie i montuje lub odmontowuje kartę SD z wykorzystaniem biblioteki FatFS.
			
		\subsection{Bateria}
			Poziom baterii jest wykrywany poprzez użycie jednego z analogowych wejść procesora. Na wejściu zastosowano dzielnik napięcia, współczynnik podziału wynosi 2. Dzięki niemu maksymalne napięcie ogniwa 4.2V równa się 2.1V, co mieści się w zakresie pomiarowym mikrokontrolera (0V - 3.3V). W pliku \lstinline|analog.cpp| zaimplementowano funkcję \lstinline|battery_voltage()|, która zwraca napięcie ogniwa po wszystkich niezbędnych przekształceniach. Dodatkowo, kod zawiera aproksymację poziomu baterii w procentach. Funkcja \lstinline|battery_percentage()| zwraca liczbę z zakresu 0 - 100, która oznacza poziom naładowania ogniwa. Na podstawie wyniku tej funkcji rysowana jest ikona baterii w górnym pasku ikon statusowych. Ma ona kolor zielony i jest w pełni naładowana gdy bateria posiada 60\% lub więcej energii, 20\% i więcej to kolor żółty, natomiast poniżej 20\% ma ona kolor czerwony.
		
	\section{Wi-Fi}
		Obsługa sieci bezprzewodowej podzielona została na 3 pod-moduły:
		\begin{itemize}
			\item \lstinline|wificonnect| -- połączenie z Wi-Fi
			\item \lstinline|wifiscan| -- skanowanie dostępnych sieci
			\item \lstinline|wifibest| -- znalezienie najlepszej sieci do połączenia po uruchomieniu
		\end{itemize}
		
		Każdy z tych modułów dodaje nowe funkcje do przestrzeni nazw \lstinline|wifi|.
		
		\subsection{Połączenie z siecią Wi-Fi}
			Głównym zadaniem tej części modułu sieciowego jest pierwsze połączenie z siecią Wi-Fi po jej manualnym wyszukaniu i podaniu hasła. Służy do tego funkcja \lstinline|connect_async()|. Tworzy ona zadanie systemu operacyjnego \lstinline|wifi conn|, które próbuje połączyć się z daną siecią. Postęp procesu jest aktualizowany na ekranie przy pomocy wskaźników do funkcji przekazanych w strukturze \lstinline|cb_fns|. Są to:
			\begin{itemize}
				\item \lstinline|upd| -- ogólna aktualizacja, zawiera opis wykonywanego aktualnie kroku,
				\item \lstinline|scan| -- aktualizacja po znalezieniu sieci o podanej nazwie, zawiera siłę sygnału,
				\item \lstinline|conn| -- wywoływane po pomyślnym podłączeniu do sieci.
			\end{itemize}
			
			Odwołanie \lstinline|conn| powoduje także zapisanie sieci z hasłem do przyszłego użycia. Dodatkowe funkcje w tym module umożliwiają inicjalizację podsystemu Wi-Fi oraz np. sprawdzenie stanu połączenia.
			
		\subsection{Skanowanie dostępnych sieci}
			Wykorzystywany przez ekran \lstinline|ScWifiScan| oraz klasę ładującą \lstinline|LoaderWifiScan|, moduł ten umożliwia przeskanowanie pobliskich sieci metodą \lstinline|scan()|. Sieci te zapisywane są do pamięci stałej przy użyciu przekazanej instancji \lstinline|LFSAccess|. Następnie ładowanie kolejnych stron wyników umożliwia funkcja \lstinline|read(n, k)|, która działa analogicznie do funkcji \lstinline|LFSorter::get_smallest_n_skip_k(n, k)|. Sortowanie odbywa się nierosnąco wg siły sygnału.
			
		\subsection{Połączenie po uruchomieniu}
			Gdy urządzenie zostanie uruchomione, użytkownik oczekuje że samo odnajdzie ono najlepszą do połączenia sieć. Zachowanie takie implementuje funkcja \lstinline|connect_best_saved()|. Wykorzystuje ona funkcje \lstinline|scan()| i \lstinline|read()| żeby pojedynczo wczytywać sieci, poczynając od tej o najwyższej sile sygnału. Gdy sieć istnieje w zapisanych sieciach, inicjowane jest połączenie. W przeciwnym wypadku ładowana jest następna sieć i tak aż do skutku, albo do wyczerpania się przeskanowanych sieci.
		
	\section{Sprzęt}
		\label{sec:hw}
		Radio jest kompletnym projektem, gotowym do odtwarzania bez zewnętrznego wzmacniacza czy głośników. Zadbano także o zasilanie akumulatorowe. Projekt schematu i płytki PCB powstały w programie KiCAD\textsuperscript{\cite{hw_kicad}}, natomiast obudowa została zaprojektowana w programie OpenSCAD\textsuperscript{\cite{hw_openscad}}.
	
		\subsection{Schemat}
			\imgh{3/hw_kicad_sch}{Schemat elektryczny radia}{1}
			
			Schemat całości systemu został pokazany na rysunku~\ref{3/hw_kicad_sch}. Podzielony został na 6 funkcjonalnych bloków, które zostały opisane poniżej.
			
			\subsubsection{Sekcja zasilania}
				Urządzenie posiada własne zasilanie oparte o dwa ogniwa litowo-jonowe o sumarycznej pojemności 4Ah i znamionowym napięciu 3.6V. Na schemacie ogniwa zaznaczono wspólnym symbolem \lstinline|BT1|. W roli układu ładowania i zabezpieczeń został wykorzystany gotowy moduł\textsuperscript{\cite{hw_mod_chg}} z układem TP4056 (\lstinline|B3|). Dzięki niemu, produkt nie wymaga dodatkowej ładowarki. Wyprowadzone zostało złącze USB~C, użytkownik może użyć każdej ładowarki o prądzie minimalnym 1A. Istotnym zadaniem sekcji zasilającej jest przełączanie źródła zasilania. Gdy ogniwa są ładowane, z terminali \lstinline|B+|, \lstinline|B-| oraz \lstinline|OUT+|, \lstinline|OUT-| pozostałe moduły nie mogą pobierać prądu. Może to spowodować przeładowanie ogniw. Tranzystor PMOS \lstinline|Q1|, dioda Schottkiego \lstinline|D1| oraz rezystor \lstinline|R5| tworzą układ\textsuperscript{\cite{hw_load_sw}}, który w trakcie ładowania przełącza  wyjście \lstinline|PWR| z zasilania bateryjnego \lstinline|OUT+| na zasilanie bezpośrednio z portu USB (\lstinline|IN+|). Dalej przetwornica wytwarza napięcie 5V do zasilenia portu USB, który w kolejnych wersjach projektu może posłużyć do podłączenia zewnętrznego modemu sieci komórkowej Obecnie nie jest on używany. Na końcu zastosowane zostały dzielniki napięcia, aby urządzenie mogło mierzyć kluczowe parametry pracy tej sekcji.
				
			\subsubsection{Panel LCD, przyciski, karta SD}
				Te trzy sekcje łączą poszczególne gotowe moduły z główną jednostką. Na uwagę jednak zasługuje zastosowanie kondensatorów w celu wygładzenia drgania styków.
				
			\subsubsection{Moduł przetwarzania dźwięku}
				Najistotniejszy z modułów. Służy do przetworzenia dźwięku cyfrowego na analogowy i regulację jego głośności. Zastosowany gotowy moduł\textsuperscript{\cite{hw_mod_dac}} oparty na PCM5102a pełni rolę przetwornika analogowo-cyfrowego. Dalej w torze audio zastosowane zostały dwa potencjometry. Pierwszy z nich, wewnętrzny służy do stałego ograniczenia poziomu dźwięku, aby nie uszkodził on wzmacniacza lub głośników. Drugi, zewnętrzny, operowany jest przez użytkownika. Na końcu jest wzmacniacz, również oparty o gotowy moduł\textsuperscript{\cite{hw_mod_amp}}. Wykorzystany układ PAM8403 przy napięciu 3.3V posiada ok. 1W mocy na kanał (głośniki $4 \Omega$). Przy napięciu 3.7V będzie to nieznacznie więcej. Wejście \lstinline|MUTE| pozwala na całkowite wyciszenie wzmacniacza, gdy nie jest on używany. Notka na dole mówi, że do zasilenia modułu konwertera wystarczy napięcie 3.7V (posiada ona własne regulatory napięcia dla minimalizacji szumów).
				
		\subsection{Płytka drukowana}
			Na podstawie wyżej opisanego schematu powstała płytka drukowana. Gwarantuje ona dobrą jakość połączeń, w porównaniu do płytki stykowej, na jakiej powstawał prototyp.
		
			\imghss{3/hw_kicad_pcb}{Projekt płytki}{3/hw_pcb}{Zmontowana, gotowa płytka (bez modułów)}
			
			Na rysunku~\ref{3/hw_kicad_pcb} przedstawiony został projekt płytki. Zaznaczono na nim dwie najważniejsze sekcje. W centrum znajduje się płytka Raspberry Pi Pico W, a w jej sąsiedztwie slot na karty SD, i przyłącza do ekranu LCD (po lewej, 8-pinowe) i przycisków (po prawej, 6-pinowe). Obok, na rysunku~\ref{3/hw_pcb}, przedstawiona została gotowa płytka.
			
		\subsection{Obudowa}
			Po zwymiarowaniu wszystkich komponentów systemu i płytki PCB powstał projekty obudowy do wydruku 3D.
			
			\lstfile{scad}{Kod generujący otwory na przyciski i śruby montażowe}{lst/3/buttons.scad}
			
			Wybór programu jest nieoczywisty ponieważ umożliwia on projektowanie 3D oparte o prosty język skryptowy. Dzięki temu podejście do projektowania może tylko nieznacznie różnić się od pisania oprogramowania. Fragment kodu opisu obudowy został przedstawiony na listingu~\ref{lst/3/buttons.scad}. Linie 3-4 generują siatkę 3x3 na której zostaną umieszczone przyciski/otwory na śruby. Operator trójargumentowy w liniach 7-8 powoduje że w rogach siatki otwory będą miały inną średnicę. Warto też zwrócić uwagę na wykorzystanie nazw zamiast wartości, co umożliwia łatwiejszą modyfikację.
			
			\imghss{3/hw_scad_case}{Finalny projekt obudowy radia}{3/hw_case}{Efekt końcowy, radio w obudowie}
			
			Na rysunku~\ref{3/hw_scad_case} przedstawiono projekt całej obudowy. Obok zaprezentowano efekt finalny, funkcjonalne radio w obudowie (rysunek~\ref{3/hw_case}).
			
\chapter{Organizacja pracy}
	W tym rozdziale opisane zostały etapy pracy nad projektem jak również organizacja pracy w trakcie jego trwania.
	
	\section{Przebieg prac}
		\imgh{4/PicoRadio-steps}{Etapy projektu}{1}
	
		Prace nad projektem rozpoczęły się w kwietniu 2023 roku. Projekt realizowany był etapami. Zostały one pokazane na rysunku~\ref{4/PicoRadio-steps} oraz opisane poniżej.
		
		\subsection{Określenie wymagań sprzętowych}
			Propozycja wykorzystania układu RP2040 była względnie ryzykowna. Rdzenie Cortex M0+ mogły okazać się niewystarczające do obsłużenia wszystkich zadań, zwłaszcza, że brak im jednostki obliczeń zmiennoprzecinkowych. Należało więc jak najszybciej określić czy poradzą sobie one z najważniejszym i najbardziej wymagającym aspektem jakim jest dekodowanie formatu MP3.
			
			\imgh{4/prototype_1}{Pierwszy prototyp do testów odtwarzania dźwięku}{0.6}
			
			W krótkim czasie powstał prototyp przedstawiony na rysunku~\ref{4/prototype_1}. Zmontowany na płytce stykowej, zawierał minimum elementów wymaganych do testów audio. Znalazły się tam układy przetwornika cyfrowo-analogowego i wzmacniacza, oraz slot na kartę SD.
			
			% commit: https://github.com/MrJake222/pico-radio/commit/f74a7883a8a824952876943f6f33ca1d82e739dd
			\lstfile{c}{Realizacja podstawowego ładowania bufora}{lst/4/prototype.c}
			
			Początkowo projekt odtwarzał tylko nieskompresowane pliki WAV. Na listingu~\ref{lst/4/prototype.c} przedstawiono jak odbywało się doładowywanie bufora danymi z karty SD. Flagi \lstinline|a_done_irq| i \lstinline|b_done_irq| były ustawianie w przerwaniach DMA. Główna pętla programu oczekiwała na te przerwania i ładowała dodatkowe dane. Dostęp do karty SD, jak i komunikacja \isqs{} z przetwornikiem działały poprawnie. Dzięki makrom \lstinline|DBG_ON| i \lstinline|DBG_OFF| ustawiającym pin mikrokontrolera w odpowiedni sposób, możliwa była zewnętrzna kontrola czasu wykonania odczytu i (później) dekodowania.
			
			% commit: https://github.com/MrJake222/pico-radio/commit/798cda3f2b81ec04788e7fbe123bc1dbff969250
			\lstfile{c}{Pomiar czasu dekodowania ramki MP3}{lst/4/benchmark.c}
			
			Dalej, przy wykorzystaniu biblioteki \lstinline|minimp3|\textsuperscript{\cite{minimp3}}, dodana została obsługa dekodowania MP3. Krótki fragment kodu na listingu~\ref{lst/4/benchmark.c} przedstawia w jaki sposób badano czas dekodowania pojedynczej ramki audio. Niestety czas przetworzenia jednej ramki wynosił ok. 90ms, co stanowiło znacząco za dużo, gdyż jedna taka ramka odtwarzana jest przez 26ms.
			$ $\\
			
			% commit: https://github.com/MrJake222/pico-radio/commit/ede28044f02faab5ef6a6204bf7e402d5687e736
			Dopiero, gdy wykorzystana została biblioteka \lstinline|helixmp3| pracująca na reprezentacji stałopozycyjnej liczb, czas dekodowania spadł do 20ms. Oznaczało to zielone światło na dalsze prace nad projektem przy wykorzystaniu tego modelu mikroprocesora.
			
		\subsection{Standaryzacja interfejsu i radio internetowe}
			Droga do działającego odtwarzacza trwała około miesiąca. Pod koniec kwietnia, odtwarzanie działało, jednak stan repozytorium pozostawiał wiele do życzenia. Istniało wiele niepowiązanych ze sobą fragmentów kodu. Odtwarzanie formatów MP3 i WAV stanowiło dwie oddzielne funkcje. Następny miesiąc minał pod szyldem refaktoryzacji kodu. Powstały wtedy takie koncepcje jak bufor kołowy dekompresja formatów (opisane w sekcjach odpowiednio \ref{sec:circular_buffer} oraz \ref{sec:decode}).
			$ $\\
			
			Podczas refaktoryzacji pliki WAV zostały zintegrowane z istniejącą obsługą plików MP3. Zaimplementowany i zintegrowany został także klient HTTP. Pod koniec maja odtwarzacz plików MP3 zamienił się w radio, zdolne odtwarzać internetowe strumienie MP3.
%			Jednak do kompletnego produktu brakowało jeszcze interfejsu użytkownika.
			
		\subsection{System operacyjny}
			\imgh{4/prototype_2}{Prototyp z wyświetlaczem i klawiaturą}{0.8}
		
			Po podłączeniu przycisków (rys.~\ref{4/prototype_2}) jasnym stało się, że projekt bez systemu operacyjnego może okazać się wyzwaniem. Wykorzystano zatem projekt FreeRTOS. System czasu rzeczywistego pozwolił na asynchroniczne obsługiwanie zdarzeń takich jak np. wciśnięcia klawiszy. Po refaktoryzacji z wykorzystaniem nowych możliwości, takich jak kolejki i powiadomienia oraz wykorzystaniu drugiego rdzenia do dekodowania, koncepcja projektu zaczęła się krystalizować.
			
			\subsubsection{Problemy z pamięcią RAM}
				Po dodaniu systemu FreeRTOS z domyślną konfiguracją okazało się, że w czasie uruchomienia, brakuje pamięci RAM.
				Postanowiono wtedy używać jedynie statycznej alokacji pamięci, żeby zauważyć i naprawić tego typu błędy w czasie kompilacji.

				\lstfile{default}{Zajętość pamięci RAM}{lst/4/memory}

				Powstało także narzędzie do analizy zużycia pamięci na podstawie pliku \lstinline|.elf.map|. Zawiera on informacje w której części przestrzeni adresowej znajdują się wszystkie zmienne w projekcie oraz ile bajtów zajmują. Skrypt \lstinline|read-elf-map.py| w języku Python analizuje ten plik. Wyświetla przyjazne dla użytkownika podsumowanie największych obiektów oraz procentową zajętość pamięci. Na listingu~\ref{lst/4/memory} że pamięć w finalnej wersji produktu została użyta w 80\%, a najwięcej pamięci alokują:
				\begin{itemize}
					\item 70kB (\lstinline|static.cpp|) -- bufor kołowy, pamięć wpisów list, instancja klienta HTTP,
					\item 49kB stos sieciowy
					\item 45kB (\lstinline|player.cpp|) -- bufor nieskompresowanego dźwięku, instancje dekoderów.
					\item 29kB system operacyjny FreeRTOS.
				\end{itemize}
			
		\subsection{Interfejs użytkownika}
			\imghss{4/first_screen_search}{Ekran wyszukiwania z klawiaturą}{4/first_screen_res}{Ekran wyników wyszukiwania}
		
			Koniec czerwca to implementacja architektury ekranów użytkownika. Na początku została dodana obsługa ekranów klawiatury (rys.~\ref{4/first_screen_search}), wyników wyszukiwania (rys.~\ref{4/first_screen_res}) i odtwarzacza. Wraz z końcem miesiąca radio było gotowe do znajdowania i odtwarzania stacji.
			
		\subsection{Problem z oknem TCP}
			Niestety, urządzenie zaczęło wykazywać nieokreślone problemy. W nieregularnych odstępach czasu odtwarzanie przestawało być płynne. Wypełnienie bufora spadało do zera, dźwięk zapętlał się.
			
			\imgh{4/tcp_fail}{Wykres ogłaszanego okna klienta TCP}{0.85}
			
			Na rysunku~\ref{4/tcp_fail} przedstawiono jak prezentuje się ogłaszane przez radio okno TCP. Jest ono z góry ograniczone jako 12kB. Od czasu ok. 1:24 rozpoczęły się wspomniane problemy. Okazało się, że gdy bufor zaczyna się wyczerpywać, nie może on zostać wystarczająco szybko uzupełniony, ponieważ ilość danych na łączu ograniczona jest przez okno TCP i opóźnienie sieci. Z tego wniosku, maksymalne ogłaszane okno zostało zwiększone do 56kB.
			$ $\\
			
			Została dobrana specjalna stacja z największym opóźnieniem (nadająca z Nowej Zelandii) wynoszącym średnio 322ms. Wykres ogłaszanego okna przedstawia rysunek~\ref{4/tcp_good}.
			
			\imgh{4/tcp_good}{Ogłaszane okno TCP maks. 56kB}{0.6}

			Jak widać podobny problem zacząłby występować ok. 40 sekundy, lecz okno mogło urosnąć do ponad 40kB i serwer szybko dostarczył brakujące dane. Problem został rozwiązany. Na uznanie zasługuje sugestia z listy mailingowej projektu LwIP. %TODO https://lists.nongnu.org/archive/html/lwip-users/2023-07/msg00001.html
			
		\subsection{Proces przyrostowy}
			Po pozbyciu się uciążliwego problemu z niewystarczającym oknem TCP, skupiono się na nowych funkcjonalnościach. W lipcu powstały m.in:
			\begin{itemize}
				\item Wyświetlanie statystyk odtwarzania,
				\item Interpretacja metadanych ICY i wyświetlanie tytułów utworów na ekranie,
				\item Lista ulubionych
			\end{itemize}
			
			Oprócz powyższych funkcjonalnych ulepszeń, odnaleziono i naprawiono szereg błędów takich jak nieprawidłowe zakańczanie odtwarzania i w konsekwencji zawieszanie się programu, niemożność wyjścia z ekranu ładowania wyników wyszukiwania czy dereferencja zerowego wskaźnika w zadaniu wypisywania statystyk po zakończeniu odtwarzania.
			
		\subsection{Schemat, płytka i obudowa}
			Gdy wymagane funkcje były już gotowe przystąpiono do stworzenia finalnego urządzenia na podstawie wyżej wspomnianego prototypu wzbogaconego o ekran i przyciski.
			$ $\\
			
			Najpierw powstał schemat połączeń elektrycznych. Uwzględnił on połączenia prototypu oraz sekcje dźwiękową. Ostatecznie nie obyło się bez poprawek. Były one nanoszone na bieżąco na schemat. Oto niektóre z nich:
			\begin{itemize}
				\item Prąd chwilowy pobierany przez wzmacniacz przekroczył możliwości przetwornicy, układ zasilony został z niższego napięcia bezpośrednio z ogniw,
				\item Dodany został pomiar napięcia baterii,
				\item Do wzmacniacza doprowadzony został sygnał wyciszający, nieodpowiednie filtrowanie zasilania powoduje szumy szczególnie słyszalne przy braku innych dźwięków,
			\end{itemize}
			
			Następna powstała płytka PCB, wytworzona domową metodą termotransferu przy użyciu żelazka\textsuperscript{\cite{ch4_pcb_method}}. Po przeniesieniu wydruku ścieżek na laminat pokryty warstwą miedzi, zostały one wytrawione roztworem nadsiarczanu sodu. Następnie zostały wywiercone otwory pod montaż przewlekany. Na rysunku~\ref{4/pcb} przedstawiono laminat po wywierceniu kilku pierwszych otworów.
			
			\imghss{4/pcb}{Płytka PCB po wytrawieniu, początek procesu wiercenia otworów}{4/prototype_3}{Kompletny prototyp na płytce}
			
			Po przetestowaniu kompletnego prototypu zmontowanego na płytce PCB (rysunek~\ref{4/prototype_3}), zaprojektowana została obudowa. Wydrukowana została na drukarce 3D. Panel frontowy pokazany został na rysunku~\ref{4/case1}.
			$ $\\
			
			Powstały dwie wersje obudowy. Druga poprawiła największy mankament wersji pierwszej, mianowicie bardzo słabo trzymające gwinty. Na podstawie wydruków testowych stwierdzono, że otwór o średnicy 2.8mm jest najlepiej dopasowany do wkrętów 3x12 (3mm szerokości). Dodatkowo zaprojektowano uchwyt do podnoszenia radia. Kompletna obudowa w wersji drugiej widoczna jest na rysunku~\ref{4/case2}.
			
			\imghss{4/case1}{Panel frontowy obudowy}{4/case2}{Kompletna obudowa}
			
			W sierpniu radio było już gotowe. Po nieznacznych korektach w oprogramowaniu (np. zmiana numerów wyprowadzeń) było produktem gotowym do testowania przez osoby postronne.

		\subsection{Testowanie}
			Pierwszym z zauważonych problemów był niewystarczający czas oczekiwania na połączenie i odbieranie danych z serwera. Radio dotychczas było testowane w bezpośrednim sąsiedztwie routera Wi-Fi. Po przeniesieniu do innego pomieszczenia radio nie mogło połączyć się z większością stacji z powodu zbyt szybkiego zgłaszania błędu przekroczenia czasu oczekiwania na dane. Został on powiększony do 4 sekund, ponieważ bufor ma 64kB, a większość stacji nadaje z przepływnością 128kb/s.
			$ $\\
			
			Użytkowanie radia jako kompletnego produktu szybko dostarczyło nowych danych o błędach. Dodana została obsługa MPEG2 (obsługa niższej jakości dźwięku), ponieważ niektóre stacje nie odtwarzały się poprawnie. Ograniczona została liczba przekierowań, na które odpowiada klient HTTP, ponieważ następowało zawieszanie się urządzenia. Długość metadanych ICY była zapisywana do zmiennej 8-bitowej co w przypadku stacji nadającej więcej informacji niż tylko tytuł utworu powodowała zawieszanie się odtwarzania. Ten błąd również został naprawiony.
			$ $\\
			
			To tylko niektóre z błędów napotkanych przeze mnie i osoby z najbliższego otoczenia. Wszystkie odnalezione były niezwłocznie zapisywane w systemie do śledzenia zadań i później naprawiane. Sierpień upłynął, radio zyskiwało na użyteczności.
			
		\subsection{Odtwarzanie plików lokalnych}
			Jako że obsługa kart SD była wymaganiem opcjonalnym, zrealizowana została pod koniec prac nad urządzeniem. We wrześniu został dodany ekran listowania plików. Za ekran wykonawczy posłużył ekran radia z pomniejszymi zmianami. Dodano pasek postępu informujący użytkownika jaka część utworu została już odtworzona. Znalazło się też miejsce na informacje o czasie trwania całości. Oba ekrany przedstawiono na rysunkach \ref{4/scr_radio} oraz \ref{4/scr_player}.
			
			\imghss{4/scr_radio}{Ekran radia}{4/scr_player}{Ekran odtwarzacza lokalnego}
			
			Zaimplementowana została także obsługa formatu metadanych ID3v2, aby móc wyświetlać autora i tytuł utworu zamiast nazwy pliku. Radio w pierwszej połowie września zyskało interfejs do odtwarzania plików lokalnych. Dalej, aż do przełomu listopada i grudnia tworzona była niniejsza dokumentacja.
			
		\subsection{Automatyczne połączenie Wi-Fi}
			Funkcjonalność ta nie była wymagana w żaden sposób do testów, stąd jej priorytet podczas prac nad projektem był relatywnie niski. 
			$ $\\

			 Do tej pory sieć Wi-Fi była zapisana na stałe w kodzie programu.  Jednak aby projekt mógł dostosowywać się do różnych miejsc pracy (różnych sieci Wi-Fi), konieczne było zaimplementowanie przechowywania wielu znanych sieci, wyszukiwania i dodawania ich przez użytkownika oraz automatyzacja procesu łączenia się z najlepszą siecią podczas startu urządzenia.
			 $ $\\
			 
			 W pierwszej połowie grudnia w.w. funkcjonalność była gotowa.
			 
	 \section{Organizacja pracy}
	 	% TODO fix jira
		Do planowania i organizacji pracy nad projektem użyto oprogramowania Jira. Główną wykorzystaną funkcjonalnością było tworzenie zadań i dzielenie ich na funkcjonalne bloki. Zawierały one implementacje podstawowych funkcjonalności takich jak: odtwarzanie lokalnych plików, automatyczne połączenia Wi-Fi.
		
		\imghss{4/plan1}{Blok ulepszeń}{4/plan2}{Zgrubny zarys dokumentacji, lokalnego odtwarzania i części sprzętowej}
		
		Bloki te zazwyczaj były następnie uruchamiane jako 1-2 tygodniowe sprinty. Przykłady takich bloków zostały przedstawione na rysunku~\ref{4/plan2}. Bloki ulepszeń (rys.~\ref{4/plan1}) czy błędów, istniały ciągle, dopisywane były do nich nowe pomysły czy zauważone błędy. Następnie mogły być one przenoszone do innych bloków.
		W ramach jednego sprintu wykorzystywana była tablica Kanban.
		 $ $\\
		 
		 Utworzono szereg własnych typów zadań. Zostały one przedstawione w tabeli~\ref{jicons}.
		 
		 \begin{table}[H]
		 	\centering
		 	\caption{Typy zadań w oprogramowaniu Jira}
		 	\label{jicons}
			 \newcommand{\jicon}[1]{\includesvg[width=12px]{img/4/jira/#1}}
			 \begin{tabular}{l|l|l}
			 	\jicon{bug}&\textit{Bug}&niedziałająca funkcjonalność\\
			 	\jicon{ref}&\textit{Refactor}&głębokie zmiany w strukturze projektu\\
			 	&&\\
			 	
			 	\jicon{docs_story}&\textit{[Docs] Story}&blok dokumentacji\\
			 	\jicon{research}&\textit{Research}&konieczność zbadania sytuacji\\
			 	\jicon{doc}&\textit{Documentation}&udokumentowanie działania\\
			 	&&\\
			 	
			 	\jicon{story}&\textit{Story}&blok zadań\\
			 	\jicon{impr}&\textit{Improvement}&ulepszenie istniejącej funkcjonalności\\
			 	\jicon{task}&\textit{Task}&nowe funkcje\\
			 	&&\\
			 	
			 	\jicon{hw}&\textit{Hardware}&poprawka sprzętowa\\
			 \end{tabular}
	 \end{table}
		 
		 Jak widać proces inspirowany był metodyką Scrum. Została ona jednak znacznie uproszczona.
	 	
\chapter{Wyniki projektu}
	W tym rozdziale skupiono się na finalnym efekcie projektu.
	
	\section{Przegląd zrealizowanych funkcji}
	
		\subsection{Odtwarzacz radiowy}
			\imghss{5/radio}{Ekran \textit{Radio} (włączone z listy ulubionych)}{5/radio_search}{Ekran \textit{Radio} (wyszukane)}
			
			Główną funkcją produktu jest odtwarzanie radia internetowego. Zrealizowane w postaci dedykowanego ekranu (rys.~\ref{5/radio}), prezentuje na nim podstawowe informacje na temat stacji radiowej oraz stanu urządzenia. Obsługa metadanych ICY pozwala na wyświetlanie tytułu granego w danej chwili. Poniżej wyświetlane są statystyki działanie dekodera. \textit{CPU} odnosi się do procentu wykorzystania rdzenia dekodującego, natomiast \textit{Bufor} informuje użytkownika o poziomie wypełnienia bufora (przydatne, gdy występują problemy z odtwarzaniem spowodowane niską jakością połączenia internetowego).
			$ $\\
			
			Na dole ekranu dostępne są 2 lub 3 ikony. Pierwsza z nich zakańcza odtwarzanie i powraca do poprzedniego ekranu. Druga, ikona gwiazdy, pozwala dodawać/usuwać stację z listy ulubionych. Jeśli jest ona wypełniona, oznacza to że stacja jest zapisana i kliknięcie jej spowoduje jej usunięcie. Natomiast pusta ikona wskazuje, że jest to nowa stacja i pozwala na dodanie jej do listy ulubionych. Trzecia ikona jest dostępna tylko w przypadku uruchomienia radia z poziomu wyników wyszukiwania (rys.~\ref{5/radio_search}). Pozwala ona wrócić bezpośrednio do ekranu listy ulubionych stacji.
		
			\paragraph{Dalszy rozwój}
				Implementacja dekodowania formatu AAC/AAC+ znacząco podniosłaby użyteczność produktu.
			
		\subsection{Lista ulubionych stacji}
			\imgh{5/fav}{Ekran \textit{Ulubione stacje}}{0.5}
			Przechowywana w pamięci urządzenia lista ulubionych stacji zawiera znalezione i zapisane przez użytkownika stacje (rys.~\ref{5/fav}).
			Ekran obsługuje stronicowanie wpisów. Domyślnie wyświetlanych jest 16 wpisów na stronę. Na dole ekranu wyświetlona jest aktualna strona i liczba wszystkich stron.
			W górnym pasku zawiera się nazwa ekranu oraz ikony statusowe (Wi-Fi, karta SD, bateria).
			$ $\\
			
			Jest to także ekran startowy. Wyświetla się on jako pierwszy po starcie programu. Dlatego jest też traktowany jako ekran główny i posiada najwięcej ikon akcji na dole ekranu.
			Ikona najbardziej po lewej to ikona folderu i uruchamia listing plików lokalnych. Zaraz obok znajduje się ikona ustawień. Po prawej użytkownik może uruchomić wyszukiwarkę stacji.
			
			\paragraph{Dalszy rozwój}
				Warto zwrócić uwagę, że stacje są zawsze dodawane na koniec listy ulubionych. Nie ma żadnej możliwości zmiany ich ustawienia. Opcja taka znacząco podniosłaby komfort użytkowania produktu. Możliwość importu/eksportu listy ulubionych stacji z/na kartę SD umożliwiłaby tworzenie kopii zapasowych listy ulubionych stacji lub też ręczne dodawanie strumieni których nie ma w obsługiwanych wyszukiwarkach stacji internetowych.
			
		\subsection{Wyszukiwarka stacji radiowych}
			\imghss{5/search}{Ekran wyszukiwania stacji}{5/searchres}{Ekran wyników wyszukiwania}
			Wyszukiwanie stacji jest dwuetapowe. Najpierw użytkownik na ekranie z klawiaturą (rys.~\ref{5/search}) podaje fragment nazwy stacji, którą chciałby wyszukać. Po kliknięciu ikony lupy w prawym dolnym rogu ekranu, ładowane są stacje pasujące do wyszukiwania. Pojawia się nowy ekran przedstawiony na rysunku~\ref{5/searchres}. Są na nim zawarte wyszukane stacje.
			$ $\\
			
			Analogicznie do ekranu ulubionych, tutaj też zawarto obsługę stronicowania wyników. Jednak nie jest dostępna liczba wszystkich wyników, stąd ikona nieskończoności na dole ekranu.
			
			\paragraph{Dalszy rozwój}
				Obecnie obsługiwany jest tylko jeden dostawca wyszukiwania. Istnieje infrastruktura do obsługi wielu takich serwerów, lecz żaden inny nie został dodany.
			
		\subsection{Przeglądarka i odtwarzacz plików lokalnych}
			\imghss{5/local}{Ekran \textit{Pliki lokalne}}{5/local_play}{Odtwarzacz plików lokalnych}
			Listing plików tworzony jest na podstawie plików znajdujących się na karcie SD (rys.~\ref{5/local}). Zapewnione jest sortowanie wpisów (foldery sortowane są jako pierwsze). Możliwe jest rekurencyjne przeglądanie drzewa katalogów. Nazwa ekranu jest dynamicznie aktualizowana i wyświetla nazwę aktualnego folderu. Jak widać obsługiwane jest także przewijanie długich tekstów poziomo na ekranie oraz dekodowanie metadanych ID3v2. Utwory w ramach jednego folderu są automatycznie odtwarzane jeden po drugim. Interfejs lokalnego odtwarzacza można zobaczyć na rysunku~\ref{5/local_play}.
			
			\paragraph{Dalszy rozwój}
				Przydatnym dodatkiem byłaby możliwość randomizacji kolejności automatycznego odtwarzania utworów oraz opcja odtworzenia całego folderu rekurencyjnie. Pozwoliłoby to np. na losowe odtworzenie całej dyskografii jednego zespołu. Implementacja bezstratnego kodowania plików FLAC umożliwiłaby podniesienie jakości odtwarzanego dźwięku.
		
		\subsection{Połączenie z Internetem}
			Urządzenie do odtwarzania radia i wyszukiwania nowych stacji wymaga połączenia z Internetem. W projekcie zostały zaimplementowane funkcje wyszukiwania, zapisywania oraz łączenia się z sieciami Wi-Fi.
			$ $\\
			
			Sieci po wyszukaniu, wprowadzeniu hasła i poprawnym ustanowieniu połączenia są zapisywane w pamięci nieulotnej. Urządzenie po uruchomieniu automatycznie wyszukuje najlepszą sieć, do której hasło zostało wcześniej zapisane. Dzięki temu, użytkownik od razu może rozpocząć odtwarzanie radia.
	
	\section{Scenariusze użytkowania}
		W tej sekcji przedstawione zostały scenariusze użytkowania urządzenia.
	
		\subsection{Wyszukanie i zapisanie stacji}
			\imgh{5/PicoRadio-fl-add}{Użytkownik dodaje stację do ulubionych}{0.9}
			\newcommand{\rfladd}[1]{\ref{5/PicoRadio-fl-add}#1}
			
			Na rysunku~\rfladd{} przedstawiono podstawowy scenariusz wyszukania stacji i dodania jej do listy ulubionych.
			
			\begin{itemize}
				\item Rys.~\rfladd{a} -- użytkownik uruchomił radio i zmienił pozycję kursora na przycisk akcji odpowiedzialny za wyszukiwanie,
				\item Rys.~\rfladd{b} -- po naciśnięciu środkowego przycisku, wyświetlony został ekran wyszukiwania z klawiaturą i wpisana została fraza filtrująca,
				\item Rys.~\rfladd{c} -- na 3. stronie odnaleziona została żądana stacja
				\item Rys.~\rfladd{d} -- po akceptacji wyboru (środkowy przycisk), rozpoczęło się odtwarzanie; użytkownik przeniósł kursor na przycisk gwiazdki,
			\end{itemize}
			Warto nadmienić, że w każdej chwili możliwa jest korekta wyboru. Gdy jednak znaleziona stacja nie jest odpowiednia lub popełniono błąd we frazie wyszukiwania, użytkownik może cofnąć się przy użyciu skrajnie lewej ikony akcji do poprzedniego ekranu.
			\begin{itemize}
				\item Rys.~\rfladd{e} -- po kliknięciu przycisku dodania do ulubionych zmienia on wypełnienie (stacja została zapisana),
				\item Rys.~\rfladd{f} -- użytkownik chce szybko powrócić do listy ulubionych stacji, więc przy pomocy prawego przycisku zmienia pozycję kursora na przycisk szybkiego powrotu,
				\item Rys.~\rfladd{g} -- nowo dodana stacja automatycznie jest wyświetlona i zaznaczona; użytkownik dostaje potwierdzenie, że zapis powiódł się.
			\end{itemize}
			
		\subsection{Odtwarzanie plików lokalnych}
			\imgh{5/PicoRadio-fl-local}{Użytkownik odtwarza lokalny plik MP3}{0.9}
			\newcommand{\rflocal}[1]{\ref{5/PicoRadio-fl-local}#1}
			
			Na rysunku~\rflocal{} przedstawiono scenariusz otwierania kolejnych lokalnych folderów i odtworzenia zapisanego na karcie SD pliku MP3.
			
			\begin{itemize}
				\item Rys.~\rflocal{a} -- użytkownik ustawił kursor na ikonie akcji odtwarzacza lokalnego,
				\item Rys.~\rflocal{b} -- po przewinięciu w dół (pasek przewijania widoczny po prawej stronie ekranu) wskazano żądany podfolder,
				\item Rys.~\rflocal{c} i \rflocal{d} -- zatwierdzając wybór użytkownik przechodzi do podfolderu; jego nazwa wyświetla się na górze ekranu,
				\item Rys.~\rflocal{e} -- klikając w plik, odtwarzanie rozpoczyna się.
			\end{itemize}
			
			Co ciekawe, pliki lokalne traktowane analogicznie do stacji radiowych, to znaczy można je dodawać do listy ulubionych.
			
		\subsection{Połączenie z nową siecią Wi-Fi}
			\imgh{5/PicoRadio-fl-wifi}{Użytkownik łączy się z nową siecią}{0.9}
			\newcommand{\rflwifi}[1]{\ref{5/PicoRadio-fl-wifi}#1}
			
			Na rysunku~\rflwifi{} przedstawiono scenariusz łączenia się z nową siecią Wi-Fi i zapisanie jej do znanych sieci.
			
			\begin{itemize}
				\item Rys.~\rflwifi{a}, \rflwifi{b}, \rflwifi{c} i \rflwifi{d} -- użytkownik przechodzi do wyszukiwania nowych sieci i znajduję tą, z którą chce się połączyć,
				\item Rys.~\rflwifi{e}, \rflwifi{f} -- otwiera się ekran wprowadzania hasła; rysunki prezentują działanie pierwszego z dwóch trybów działania przycisku \textit{Shift} (tymczasowe działanie),
				\item Rys.~\rflwifi{g}, \rflwifi{h} -- tutaj, poprzez podwójne naciśnięcie, został wybrany drugi tryb \textit{Shift} (stałe działanie),
				\item Rys.~\rflwifi{i}, \rflwifi{j} -- po wprowadzeniu hasła, otwiera się ekran połączenia, na którym prezentowany jest aktualny status połączenia i ewentualne błędy,
				\item Rys.~\rflwifi{k} -- gdy połączenie się powiedzie, przycisk wstecz przenosi użytkownika do listy zapisanych sieci (zamiast do poprzedniego ekranu),
				\item Rys.~\rflwifi{l} -- użytkownik może teraz z powodzeniem słuchać radia korzystając z nowej sieci Wi-Fi.
			\end{itemize}
			
	\section{Podsumowanie wytworzonego oprogramowania}
		Produkt końcowy posiada wiele funkcji. Przeważająca większość z nich jest kompletna.
		% TODO dopisać coś
		
		\subsection{Ocena obecnej wersji produktu}
			Udało się zaimplementować dekodowanie MP3 z każdą przepływnością, nawet 320 kbps, w wariantach MPEG1 oraz MPEG2. Ponad to obsługiwane są pliki WAV. Udało się także odczytać metadane zarówno strumieni internetowych (ICY) jak i lokalnych plików MP3 (ID3v2). Dekoder potrafi uwzględniać i korygować wiele nieprawidłowości w strumieniu danych. Obsługiwane jest także wykrywanie i zgłaszanie błędów dekodowania. Klient HTTP obsługuje minimum funkcji, lecz jest to wystarczające do poprawnego strumieniowania radia internetowego.
			$ $\\
			
			Należałoby poprawić dokładność wyliczania procentu pozostałej energii w ogniwach. Aproksymacja zgrubnie jest poprawna lecz do pełnej poprawności brakuje wielogodzinnych testów i poprawek. Podczas ładowania, wskazanie poziomu baterii jest znacznie zawyżone.
			$ $\\
			
			Błędy zgłaszane użytkownikowi są zbyt ogólne. Konieczna jest unifikacja kodów błędów w projekcie i wyświetlanie adekwatnej wiadomości zamiast ogólnikowego \textit{Wystąpił błąd}. Brak jest także ekranu potwierdzenia usunięcia wpisu z ulubionych oraz edycji nazwy zapisanej stacji.
		
		\subsection{Perspektywa nowej generacji projektu}
			Swoista wersja 2.0 mogłaby zawierać przykładowo obsługę modemów USB. Dzięki temu, użytkownik mógłby podłączyć do płytki modem sieci komórkowej i używać urządzenia bez dostępu do sieci Wi-Fi (np. w miejscu pracy). Taki produkt nie wymagałby żadnej konfiguracji początkowej ani ingerencji w istniejącą infrastrukturę sieciową. Jest to duża zaleta tradycyjnego radia.
			$ $\\
			
			Część stacji internetowych próbuje wymusić połączenie szyfrowane TLS. Obecnie radio odrzuca takie próby i zgłasza błąd. Dołączenie do projektu obsługi takich połączeń podniosłoby jego użyteczność. Powstały jednak obawy czy urządzenie poradzi sobie z deszyfrowaniem danych w czasie rzeczywistym, więc kwestia TLS nie została poruszona w obecnej wersji projektu.
			$ $\\
			
			Istniejąca infrastruktura pozwala na zaimplementowanie tworzenia wielu list ulubionych, jednak tak funkcjonalność nie została utworzona. Gdyby ją zaimplementowano, użytkownik mógłby grupować swoje utwory według własnego uznania. Odtwarzanie np. konkretnych gatunków muzycznych stałoby się o wiele prostsze.
			
	\section{Warstwa sprzętowa}
		Projekt od strony sprzętowej został udokumentowany w sekcji~\ref{sec:hw}. Oprócz schematu, powstała także płytka PCB, oraz obudowa wydrukowana przy użyciu drukarki~3D. Całość widoczna jest na rysunku~\ref{5/hw_result}.
		
		\imgh{5/hw_result}{Gotowy produkt w obudowie}{0.7}
		
		Od strony funkcjonalnej urządzenie posiada wbudowane ogniwa, dzięki czemu nie potrzebuje zewnętrznego zasilania. Zintegrowany układ ładowania ze złączem USB~C pozwala na wykorzystanie praktycznie dowolnej ładowarki z tym złączem (prąd wykorzystany do ładowania to 1A). Produkt posiada analogową regulację głośności potencjometrem wyprowadzonym na lewą stronę urządzenia. Lokalizacja została dobrana ze względu na bliskość sekcji audio na płytce i chęć minimalizacji długości ścieżek, które im dłuższe tym większe zakłócenia wprowadzają do systemu. Obok gałki potencjometru znajduje się także złącze JACK~3.5mm do podłączenia zewnętrznego wzmacniacza.
		
		\subsection{Ocena wyników}
			Natura sprzętowej realizacji tej części projektu powoduje, że znacznie ciężej jest korygować powstałe błędy. Dlatego ta sekcja zawiera dużo niedociągnięć. Jednak wszystkie te mankamenty mogą zostać naprawione w nowej wersji sprzętu.
			
			\subsubsection{Schemat}
				\noindent
				Podczas tworzenia pierwszej wersji schematu popełniono szereg drobnych błędów:
				\begin{itemize}
					\item brak kondensatorów filtrujących, które mogłyby poprawić parametry pracy niektórych elementów takich jak wzmacniacz,
					\item RP2040 mierzy napięcie \lstinline|VCC| a nie napięcie ogniw, co powoduje, że podczas ładowania nie ma on możliwości pomiaru poziomu naładowania,
					\item niedokładne rezystory pomiarowe w dzielnikach napięć, powodują one niedokładności w pomiarze napięć \lstinline|VCC| i ogniw,
					\item brak ochrony przed drganiem styków (kondensatorów) pinów detekcji karty SD,
					\item zastosowana przetwornica nie jest przystosowana do wysokiego, skokowego poboru prądu przez wzmacniacz,
					\item wzmacniacz powinien mieć pin wyciszający lub wyłączający, aby obniżyć pobór prądu i ukrywać szumy przy braku odtwarzania dźwięków,
				\end{itemize}
				
				W przedstawionym finalnym schemacie powyższe pomyłki zostały naprawione. Na płytce brakujące połączenia były wykonywane przy użyciu przewodów lutowanych bezpośrednio do płytki od strony miedzi.
				$ $\\
				
				Dodatkowo wykryte zostały problemy, które nie zostały poprawione w tej wersji produktu. Parametr $\text{RDS}_{\text{(on)}}$ tranzystora \lstinline|Q1| przy małych napięciach jest relatywnie duży, co przy znacznym poborze prądu przez wzmacniacz powoduje odkładanie się na nim nietrywialnej mocy. Przykładowym rozwiązaniem tego problemu może być zastosowanie tranzystora o lepszych parametrach, lub zrezygnowanie wbudowanej ładowarki ogniw.
				$ $\\
				
				Niewystarczające filtrowanie zasilania powoduje słyszalne szumy, szczególnie wtedy, kiedy nic nie jest odtwarzane. Komunikacja Wi-Fi powoduje znaczny chwilowy wzrost prądu pobieranego przez płytkę Pi~Pico~W, co powoduje zakłócenia w zasilaniu wzmacniacza. Częściowo zostało to naprawione przez wyciszanie wzmacniacza, lecz nie jest to rozwiązanie idealne. Należałoby odseparować od siebie te dwa obwody zasilające.
				
			\subsubsection{Płytka PCB}
				Przy projektowaniu płytki PCB również wystąpiły niedopatrzenia:
				\begin{itemize}
					\item brak otworów montażowych w obrębie głównej części płytki, przez co posiada ona dość niestandardowy kształt,
					\item brak miejsca na elementy spajające obudowę, tam gdzie płytka dotyka ścianek nie ma wkrętów mocujących, co powoduje niestabilność obudowy,
					\item moduły są wpinane w złącza typu \textit{goldpin}, co w przypadku obecności na nich złącz zewnętrznych (JACK, port USB~C), powoduje że wpinanie wtyków w te złącza odchyla je i w konsekwencji moduł wypada lub traci kontakt. Zostało to częściowo naprawione przy module ładowania. Wlutowany na stałe, stał się stabilniejszy.
				\end{itemize}
				
				Domowa metoda termotransferu nie zapewnia najlepszych parametrów produkcyjnych. Niektóre ścieżki są cieńsze niż w projekcie, a część padów jest tak cienka, że montaż był znacząco utrudniony. Znacznie lepszym i powtarzalnym sposobem na wytworzenie płytki byłoby zlecenie jej wykonania zewnętrznej firmie, jednak znacznie opóźnia to prototypowanie.
		
		\subsection{Radio nowej generacji}
			Pierwszym ulepszeniem powinna być nowa płytka, zaprojektowana od podstaw z uwzględnieniem powyższych uwag. Wykonana profesjonalnie, dwuwarstwowo, pozwoliłaby na miniaturyzację urządzenia i poprawienie parametrów pracy, głównie obniżenie szumów sekcji zasilającej. Powinny zostać uwzględnione wszystkie otwory montażowe samej płytki jak i elementy obudowy z którymi nie może kolidować. Moduły powinny zostać odsunięte od krawędzi płytki, ponieważ (jak napisano wyżej) i tak nie nadają się do bezpośredniego wpinania zewnętrznych złączy. Za to powinny zostać wyprowadzone dedykowane, lutowane lub przykręcane złącza.
			$ $\\

			Należałoby się zastanowić także, czy jakość i poziom głośności dźwięku odpowiada użytkownikowi. Jeżeli nie, istnieje możliwość wykorzystania mocniejszego wzmacniacza w celu obniżenia zniekształceń przy cichym słuchaniu lub zwiększenia mocy maksymalnej. Jednak układy o większej mocy wymagają wyższego napięcia.
			Przykładowo PAM8610\textsuperscript{\cite{ch5_pam8610}} przy napięciu 7V (przybliżone napięcie 2 ogniw połączonych szeregowo) jest w stanie oddać moc 4W na kanał (obecnie użyty wzmacniacz posiada moc ok. 1W na kanał). Nowszy PAM8006a\textsuperscript{\cite{ch5_pam8006a}} jest w stanie wysterować głośniki mocą aż 8W na kanał, lecz wiąże się to z napięciem zasilania 12V (3 ogniwa szeregowo) i zmianą głośników na takie o impedancji $8 \Omega$.
			Jednak pociąga to za sobą komplikacje sekcji zasilającej. Ogniwa szeregowe musiałyby być ładowane wyższym napięciem i prawdopodobnie poskutkowałoby to zrezygnowaniem z wysokiej kompatybilności USB~C. Dostarcza ono zbyt niskiego napięcia. Istnieje opcja wykorzystania protokołu USB~PD (ang. \textit{power delivery}), który, może poinformować ładowarkę, że urządzenie obsługuje napięcie wyższe niż 5V, np. 9V czy 12V.
			$ $\\
			
			Dodatkowym modułem poprawiającym jakość dźwięku mógłby być prosty \textit{equalizer}. Dwa pokrętła do wyrównania pasma akustycznego (bas i treble), zrealizowane z wykorzystaniem pasywnych elementów elektronicznych.
			
	\section{Podsumowanie}
	
		W niniejszej pracy inżynierskiej udało się zaprojektować i zbudować odbiornik internetowych stacji radiowych z opcją odtwarzania plików lokalnych.
		Wszystkie założone cele zostały spełnione. Pomimo kilku niedociągnięć urządzenie jest w pełni funkcjonalne i z powodzeniem może być wykorzystane do odtwarzania radia internetowego i lokalnych plików MP3 oraz WAV. Powstała też założona obudowa, dzięki której radio nabiera wyglądu kompletnego produktu.
		$ $\\
		
		Projekt uważam za udany. 
		Z efektów pracy jestem nad wyraz zadowolony. Urządzenie da się wykorzystać do codziennego słuchania radia czy muzyki.
%		Wbudowane ogniwa zapewniają przenośność urządzenia
		Klient (promotor) również jest zadowolony. Temat był propozycją promotora. Zostały zrealizowane, a nawet przekroczone wszystkie jego założenia. Ponad wymagania zrealizowano projekt płytki czy obudowy, w której został zamknięty finalny produkt.
		$ $\\
		
		Dużo się nauczyłem.
		Znacząco rozwinąłem swoje umiejętności programowania w języku C++, szczególnie w zakresie tworzenia i utrzymywania średniego rozmiaru projektów. Zaprezentowane hierarchę klas były implementowane i refaktoryzowane przez kilka miesięcy. Pozwoliło mi to na doskonalenie dobrych praktyk programistycznych.
		
		$ $\\
		Druk 3D był dla mnie nowym obszarem zainteresowań. Udało mi się dobrać odpowiedni program, zaprojektować i wydrukować obudowę projektu. 
		Mój warsztat został doposażony, drukarka na pewno okaże się pomocna w przyszłych projektach.
			
	% TODO warnings gdzieś przy flow??
	% TODO instrukcja obsługi (rozdział 5) ??
		
	\pagebreak
	\begin{thebibliography}{9}
		\bibitem{radio-browser}
		\href{https://www.radio-browser.info/}{\textit{Radio-browser} -- baza danych stacji radiowych}
		\bibitem{fmstream}
		\href{http://fmstream.org}{\textit{fmstream} -- baza danych stacji radiowych}
		
		\bibitem{minimp3}
		\href{https://github.com/lieff/minimp3}{\textit{minimp3} -- biblioteka dekodująca MP3}
		\bibitem{realnetworks}
		\href{https://realnetworks.com}{\textit{RealNetworks} -- firma odpowiedzialna za bibliotekę \textit{helixmp3}}
		\bibitem{helixmp3_repo}
		\href{https://github.com/ultraembedded/libhelix-mp3}{\textit{helixmp3} -- biblioteka dekodująca MP3 (napisana w 2003 roku przez RealNetworks)}
		
		\bibitem{rp2040}
		\href{https://www.raspberrypi.com/documentation/microcontrollers/rp2040.html}{\textit{RP2040} -- Mikrokontroler firmy Raspberry Pi}
		\bibitem{pico_sdk}
		\href{https://github.com/raspberrypi/pico-sdk}{\textit{pico-sdk} -- Zestaw bibliotek do Raspberry Pi Pico}
		\bibitem{freertos_kernel}
		\href{https://github.com/FreeRTOS/FreeRTOS-Kernel}{\textit{FreeRTOS Kernel} -- Jądro systemu czasu rzeczywistego FreeRTOS}
		\bibitem{adafruit_st7735}
		\href{https://github.com/adafruit/Adafruit-ST7735-Library}{\textit{Adafruit-ST7735-Library} -- biblioteka do obsługi ekranów LCD napisana przez firmę Adafruit}
		\bibitem{littlefs}
		\href{https://github.com/littlefs-project/littlefs}{\textit{LittleFS} -- System plików przeznaczony do pamięci flash}
		\bibitem{fatfs}
		\href{http://elm-chan.org/fsw/ff/00index_e.html}{\textit{FatFS} -- Obsługa systemów plików z rodziny FAT}
		\bibitem{sdfs}
		\href{https://github.com/carlk3/no-OS-FatFS-SD-SPI-RPi-Pico}{\textit{FatFS+SPI na Pi Pico} --  kompleksowa biblioteka łącząca FatFS i komunikację poprzez SPI z kartą SD (przystosowana do Pi Pico)}
		
		\bibitem{radio_adapter}
		\href{https://allegro.pl/oferta/adapter-radia-internetowego-dual-ir-3a-dab-fm-rds-12692108793}{\textit{Radio sieciowe} -- Sklep Allegro}
		\bibitem{radio_tanie}
		\href{https://www.x-kom.pl/p/653480-radio-internetowe-technisat-sternradio-ir-2-biale.html}{\textit{Radio internetowe mono} -- Sklep x-kom}
		\bibitem{radio_drogie}
		\href{https://www.x-kom.pl/p/724674-radio-internetowe-blaupunkt-ir10bt.html}{\textit{Radio internetowe stereo} -- Sklep x-kom}
		\bibitem{botland_stm}
		\href{https://botland.com.pl/stm32-discovery/4715-stm32f746g-disco-discovery-stm32f746ng-cortex-m7-ekran-dotykowy-pojemnosciowy-43--5904422374082.html}{\textit{STM32F746G-Disco} -- Sklep Botland}
		
		\bibitem{radio_pico1}
		\href{https://github.com/episource/picopdio}{\textit{picopdio} -- Przykładowe radio internetowe Raspberry Pi Pico}
		\bibitem{radio_vs1003}
		\href{https://botland.com.pl/odtwarzacze-mp3-wav-ogg-midi/14308-odtwarzacz-mp3-vs1003-z-mikrofonem-5903351241786.html}{\textit{VS1003} -- Sprzętowy dekoder MP3}
		
		\bibitem{figma}
		\href{https://www.figma.com}{\textit{Figma} -- Narzędzie do projektowania interfejsów}
		
		\bibitem{pico_pdf}
		\href{https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf}{\textit{RP2040 Datasheet} -- dokumentacja techniczna procesora RP2040}
		\bibitem{tda_pdf}
		\href{http://www.lampizator.eu/lampizator/LINKS%20AND%20DOWNLOADS/DATAMINING/tda%201543.pdf}{\textit{TDA1543 Datasheet} -- dokumentacja techniczna układu DAC TDA1543}
		
		\bibitem{radio_browser_codecs}
		\href{https://www.radio-browser.info/codecs}{\textit{Radio browser codecs} -- kodeki audio wylistowane na stronie Radio Browser}
		\bibitem{helixmp3_pr}
		\href{https://github.com/ultraembedded/libhelix-mp3/pull/3}{\textit{helixmp3 pull request} -- ulepszenia biblioteki dekodującej}
		
		\bibitem{icy_spec}
		\href{https://gist.github.com/niko/2a1d7b2d109ebe7f7ca2f860c3505ef0#file-icy_meta-md}{\textit{ICY} -- protokół przesyłania metadanych}
		\bibitem{id3_spec_mutagen}
		\href{https://mutagen-specs.readthedocs.io/en/latest/id3/id3v2.4.0-structure.html}{\textit{ID3v2.4.0} -- protokół zapisu metadanych w plikach MP3}
		
		\bibitem{m3u}
		\href{https://en.wikipedia.org/wiki/M3U}{\textit{M3U} -- format zapisu playlist}
		\bibitem{pls}
		\href{https://en.wikipedia.org/wiki/PLS_(file_format)}{\textit{PLS} -- format zapisu playlist}
		
		\bibitem{ubuntu_font}
		\href{https://design.ubuntu.com/font}{\textit{Ubuntu font} -- czcionka wykorzystana do wyświetlania znaków}
		
		\bibitem{hw_mod_chg}
		\href{https://botland.com.pl/moduly-ladowania-lipol-usb-micro-usb/16979-ladowarka-li-pol-tp4056-pojedyncza-cela-1s-37v-usb-typ-c-z-zabezpieczeniami--5904422326708.html}{\textit{Ładowarka Li-Pol TP4056 USB C} -- moduł ładowania ogniw}
		\bibitem{hw_load_sw}
		\href{https://www.best-microcontroller-projects.com/tp4056-page2.html}{\textit{TP4056 Power Sharing Problem} -- układ przełączania obciążenia}
		\bibitem{hw_mod_dac}
		\href{https://www.aliexpress.com/item/1005002846127078.html}{\textit{Interfejs I2S PCM5102A} -- przetwornik cyfrowo-analogowy}
		\bibitem{hw_mod_amp}
		\href{https://botland.com.pl/odtwarzacze-mp3-wav-ogg-midi/6641-wzmacniacz-audio-stereo-pam8403-5v-3w-dwukanalowy-zielony-5904422359850.html}{\textit{Wzmacniacz audio stereo PAM8403} -- dwukanałowy wzmacniacz audio}
		\bibitem{hw_kicad}
		\href{https://www.kicad.org/}{\textit{KiCAD} -- program do tworzenia schematów elektrycznych i projektowania płytek PCB}
		\bibitem{hw_openscad}
		\href{https://openscad.org/}{\textit{OpenSCAD} -- program do skryptowego projektowania 3D}
		
		\bibitem{ch4_pcb_method}
		\href{http://mikrokontrolery.blogspot.com/2011/03/wykonanie-plytki-pcb-metoda-termotransferu.html}{\textit{PCB: Metoda termotransferu} -- domowa metoda wytworzenia płytki PCB}
		
		\bibitem{ch5_pam8610}
		\href{https://www.diodes.com/assets/Datasheets/products_inactive_data/PAM8610.pdf}{\textit{PAM8610} -- 2x10W wzmacniacz audio}
		\bibitem{ch5_pam8006a}
		\href{https://www.diodes.com/assets/Datasheets/PAM8006A.pdf}{\textit{PAM8006A} -- 2x15W wzmacniacz audio}
		
	\end{thebibliography}
	
\end{document}
