% !TeX spellcheck = pl_PL
\documentclass[12pt]{report}

\usepackage{amssymb} % symbol kąta
\usepackage[polish]{babel} % polskie nazwy
\usepackage[T1]{fontenc} % polskie znaki
\usepackage[margin=1.0in]{geometry} % marginesy
\usepackage[utf8]{inputenc}
\usepackage{listingsutf8} % bloki kodu
\usepackage{lmodern} % font
\usepackage{color} % kolory
\usepackage{indentfirst} % wcięcie w pierwszej linii paragrafu
\usepackage{graphicx} % obrazy
\usepackage{float} % dla image [H]
\usepackage{amsmath,amsthm,amssymb,mathtools} % matematyka dowód
\usepackage{changepage} % matematyka dowód
\usepackage{siunitx} % wyrównanie do kropki
\usepackage{makecell} % wyrównania nagłówków
\usepackage{hyperref} % bez obwódek wokół linków
\hypersetup{
	colorlinks,
	citecolor=black,
	filecolor=black,
	linkcolor=black,
	urlcolor=magenta
}
\usepackage{caption} % link przenosi do góry obrazka

% bez odstępu w itemize
\let\tempone\itemize
\let\temptwo\enditemize
\renewenvironment{itemize}{\tempone\setlength{\itemsep}{0cm}}{\temptwo}

\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}  

% Obrazki
% ścieżki do obrazków
\graphicspath{ {img/} }

% obrazek {nazwa.png}{opis}{rozmiar}{H - wymuszanie}
\newcommand{\imgint}[4]{
	\begin{figure}[{#4}]
		\centering
		\includegraphics[width=#3\textwidth]{#1}
		\caption{#2}
		\label{#1}
	\end{figure}
}

% obrazek {nazwa.png}{opis}{rozmiar} (bez wymuszania)
\newcommand{\imgcs}[3]{\imgint{#1}{#2}{#3}{}}

% obrazek {nazwa.png}{opis} (domyślny rozmiar)
\newcommand{\img}[2]{\imgcs{#1}{#2}{0.7}}

% obrazek {nazwa.png}{opis}{rozmiar} (wymuszona pozycja)
\newcommand{\imgh}[3]{\imgint{#1}{#2}{#3}{H}}

% dwa obrazki {1}{opis 1}{2}{opis 2}{H - wymuszanie}
\newcommand{\imgintss}[5]{
	\begin{figure}[{#5}]
		\centering
		\begin{minipage}{.45\textwidth}
			\centering
			\includegraphics[width=1\linewidth]{#1}
			\caption{#2}
			\label{#1}
		\end{minipage}%
		\hfill
		\begin{minipage}{.45\textwidth}
			\centering
			\includegraphics[width=1\linewidth]{#3}
			\caption{#4}
			\label{#3}
		\end{minipage}
	\end{figure}
}

% dwa obrazki {1}{opis 1}{2}{opis 2} (bez wymuszania)
\newcommand{\imgss}[4]{\imgintss{#1}{#2}{#3}{#4}{}}

% dwa obrazki {1}{opis 1}{2}{opis 2} (wymuszona pozycja)
\newcommand{\imghss}[4]{\imgintss{#1}{#2}{#3}{#4}{H}}

% tabela z wynikami {nazwa.txt}{opis}
\newcommand{\tab}[2]{
	\begin{table}
		\centering
		\caption{#2}
		\vspace{0.3cm}
		\input{#1}
	\end{table}
}

% nagłowek tabeli bold
\renewcommand\theadfont{\bfseries}

% interfejs I2S
\newcommand{\isqs}{$\text{I}^{2}\text{S}$}
% side-set
\newcommand{\sset}{\lstinline|side-set|}

\lstdefinestyle{pio}{
	basicstyle={\ttfamily \footnotesize},
	morekeywords={out, side, jmp, set},
	numbers=left,
	backgroundcolor=\color{lbcolor}
}

\begin{document}
	\lstset{inputencoding=utf8, basicstyle=\ttfamily}
	
	\title{Odbiornik internetowych stacji radiowych \\
		\vspace{0.2cm}
		\large Praca Inżynierska \\
		\large ...}
	\author{Norbert Morawski}
	
	\maketitle
	\tableofcontents
	\pagebreak
	
	\chapter{Cel prac i wizja produktu}
	W tym rozdziale opisano jak będzie wyglądał końcowy produkt. Zwrócono też uwagę na to jak będzie przebiegała jego realizacja i jakie ryzyka mogą wystąpić.
	
	\section{Opis problemu}
		Radio internetowe staje się co raz popularniejsze. Wolność transmisji, brak regulacji pasma radiowego powodują, że wiele niezależnych stacji radiowych wybiera właśnie to medium przekazu. Jednak większość funkcjonujących współcześnie odbiorników nie posiada funkcji odbioru strumienia internetowego. Celem pracy jest wykonanie kompletnego przenośnego urządzenia, które umożliwiłoby odbiór takich stacji.
		
	\section{Rola produktu}
		Radio jest skierowane do osób z małą wiedzą technologiczną. To znaczy, obsługa urządzenia powinna być prosta i intuicyjna. Nie powinny być wymagane żadne dodatkowe elementy do eksploatacji (zewnętrzne głośniki, specjalna ładowarka). Produkt ma być kompletnym urządzeniem gotowym do odbioru radia. Całość będzie zamknięta w obudowie. Na rysunku~\ref{1/radio_proj_trimmed} przedstawiony został projekt wizualny radia. Rysunek~\ref{1/PicoRadio_blocks} przedstawia uproszczony schemat blokowy urządzenia.
		
		\imgcs{1/radio_proj_trimmed}{Projekt wizualny radia (z zachowanymi proporcjami)}{0.9}
		\imgcs{1/PicoRadio_blocks}{Schemat blokowy radia}{1}
		
	\section{Współpracujące systemy}
		Oczywistym współpracującym systemem jest w przypadku tego projektu serwer strumieniujący radio internetowe. Standardem kodowania wykorzystywanym przez serwery jest format MP3 lub AAC/AAC+. Drugim współpracującym systemem jest baza danych zawierająca stacje radiowe. Baza taka powinna umożliwiać zapytania poprzez udokumentowane i dostępne API. List baz brana pod uwagę przy projektowaniu urządzenia:
		\begin{itemize}
			\item Radio-browser\textsuperscript{\cite{radio-browser}}
			\item fmstream\textsuperscript{\cite{fmstream}}
		\end{itemize}
		
		Druga baza, choć obszerniejsza (86,000 a 38,578 stacji), nie udostępnia interfejsu dla wszystkich. Autor życzy sobie osobistej prośby o dostęp, która na ten moment została wysłana i czeka na odpowiedź.
		
	\section{Wymagania}
		Główną funkcją budowanego urządzenia ma być możliwość odtwarzania radia internetowego.
		
		\subsection{Wymagane funkcjonalności}
			\begin{itemize}
				\item odtwarzanie stacji internetowych,
				\item wstrzymywanie odtwarzania,
				\item prezentacja na zintegrowanym wyświetlaczu aktualnego stanu,
				\item regulacja głośności odtwarzania,
				\item lista stacji,
				\item lista ulubionych stacji.
			\end{itemize}
			
			\paragraph{Dodatkowe funkcjonalności (niewymagane)}
			\begin{itemize}
				\item odtwarzanie plików z nośnika przenośnego,
			\end{itemize}
		
			\paragraph{Oczekiwany produkt}
			\begin{itemize}
				\item W pełni funkcjonalny prototyp urządzenia realizującego funkcje odbiornika internetowych stacji radiowych,
				\item Dokumentacja techniczna pozwalająca na zbudowanie urządzenia oraz rozwój jego oprogramowania układowego.
			\end{itemize}
		
		\subsection{Wymagania niefunkcjonalne}
			Urządzenie ma być wykonane z wykorzystaniem mikrokontrolera, lub płytki rozwojowej opartej o mikrokontroler. Rozwiązanie powinno obsługiwać połaczenie z Internetem, np. WiFi, do pobierania strumienia danych audio z serwera oraz musi poradzić sobie z dekodowaniem formatu MP3 lub AAC w czasie rzeczywistym.
			
			Zdecydowano się też na miniaturyzację wyświetlacza i zastosowanie do obsługi urządzenia kilku przycisków. Z uwagi na małą moc obliczeniową mikrokontrolera, regulacja głośności odbywać się będzie analogowym potencjometrem.
		
	\section{Przegląd konkurencyjnych rozwiązań}
		Ceny komercyjnych adapterów radia internetowego zaczynają się od ok. 330 zł za produkt powystawowy (Rysunek~\ref{1/radio_adapter}). Wieże z wbudowaną opcją radia internetowego to koszt rzędu 230 zł za najtańszy produkt z głośnikiem mono (Rysunek~\ref{1/radio_tanie}) lub ok. 370 zł za wersję stereo (Rysunek~\ref{1/radio_drogie}). Chciałbym mój produkt zrealizować kosztem przystępnym dla hobbystycznego amatora elektroniki. Wykluczam zatem użycie gotowych, drogich płytek rozwojowych, takich jak np. \textit{STM32F746G-Disco} kosztującej 389 zł (Rysunek~\ref{1/botland_stm}).
		
		Jednym z założeń pracy jest skonstruowanie systemu, którego dokumentacja pozwoli dowolnemu informatykowi/elektronikowi na skonstruowanie podobnego urządzenia i modyfikację jego oprogramowania. Projekt sam w sobie jest ciekawy ponieważ w Internecie mało jest prób konstrukcji radia internetowego opartego o Raspberry Pi Pico. Nie znaleziono żadnych projektów dekodujących samodzielnie format MP3.  Jeden z projektów\textsuperscript{\cite{radio_pico1}} używa sprzętowego dekodera MP3 (przedstawiony na rysunku~\ref{1/radio_mp3}). Większość odtwarzaczy własnej konstrukcji opiera się o pełnoprawny komputer jednopłytkowy Raspberry Pi, który jest obecnie trudno dostępny.
		
		Urządzenie będzie także posiadać prosty i intuicyjny interfejs, aby trafić do szerokiej grupy odbiorców. Zastosowane zostaną ogniwa ładowalne, tak, aby użytkownik przy pomocy np. portu USB mógł je naładować po wyczerpaniu.
		
		\img{1/radio_adapter}{Adapter radia internetowego \textsuperscript{\cite{radio_adapter}}}
		\imgss{1/radio_tanie}{Radio internetowe mono \textsuperscript{\cite{radio_tanie}}}{1/radio_drogie}{Radio internetowe stereo \textsuperscript{\cite{radio_drogie}}}
		
		\img{1/botland_stm}{Droga płytka STM\textsuperscript{\cite{botland_stm}}}
		
		\img{1/radio_mp3}{Sprzętowy dekoder MP3 \textsuperscript{\cite{radio_vs1003}}}
		
	\section{Analiza technologiczna}
		Do realizacji projektu wybrany został bogato wyposażony mikrokontroler Raspberry Pi RP2040\textsuperscript{\cite{rp2040}}. Jednak pojawiły się obawy o możliwość dekodowania formatu MP3 w czasie rzeczywistym.
		
		\subsection{Biblioteka dekodująca}
			Standardowa ramka MP3 odtwarzana jest przez ok. 26ms. Początkowe testy z biblioteką \lstinline|minimp3|\textsuperscript{\cite{minimp3}} do dekodowania formatu MP3 nie przyniosły obiecujących rezultatów.  Przy użyciu tej biblioteki ramka była dekodowana w 90ms. Jednak wykorzystanie \lstinline|helixmp3|\textsuperscript{\cite{helixmp3}} pozwoliło na zdekodowanie ramki w 22ms (80\% dostępnego czasu) przy domyślnym taktowaniu procesora.  Używa ona matematyki stałoprzecinkowej, co w przypadku jednostki bez koprocesora matematycznego stanowi dużą przewagę.
			
			Martwiące może się wydawać poświęcenie 80\% czasu procesora na dekodowanie formatu, jednak jako że mikrokontroler jest dwurdzeniowy, cały jeden rdzeń może zostać wykorzystany do dekodowania.
		
		\subsection{Oprogramowanie}
			Oprogramowanie zostanie napisane w języku C++ z wykorzystaniem środowiska \lstinline|pico-sdk|\textsuperscript{\cite{pico_sdk}}.  W środowisko brak wbudowanego centralnego systemu zarządzającego przepływem informacji oraz zadaniami, zatem do projektu dołączone zostało jądro systemu czasu rzeczywistego FreeRTOS\textsuperscript{\cite{freertos_kernel}}
	
	\section{Ryzyko}
		Należy uwzględnić ryzyko opóźnień w ustalonym trybie prac. Tworzenie oprogramowania wiąże się z ryzykiem dotarcia w ślepy zaułek i konieczności gruntownego przeprojektowania części systemów. Dostosowanie platformy pod centralny system czasu rzeczywistego stanowi przykład takiego opóźnienia. Posiadając jedną płytkę Raspberry Pi Pico, jej uszkodzenie również może powodować opóźnienia w realizacji projektu. Warto zaopatrzyć się w więcej niż jedną sztukę krytycznych elementów. Niespodziewane problemy z jakością oprogramowania, takie jak na przykład ciężko reprodukowalne błędy w strumieniowaniu audio, także mogą przyczynić się do wielu godzin poszukiwania przyczyn takiego zachowania aplikacji.
		Dobre planowanie, rzetelne projektowanie i tworzenie aplikacji powinny umniejszyć rolę w.w. ryzyk.
	
	\section{Słownik pojęć}
		\begin{itemize}
%			\item MP3 (\textit{MPEG-1 Audio Layer 3}) -- popularny format zapisu dźwięku; implementuje stratną kompresję,
			\item AAC/AAC+ (\textit{Advanced Audio Coding}) -- inny format dźwięku z kompresją stratną
%			\item Li-ion -- akumulatory Litowo-jonowe (ładowalne)
			\item Raspberry Pi -- komputery jednopłytkowe tworzone przez Raspberry Pi Foundation
			\item Raspberry Pi Pico -- płytki rozwojowe oparte o mikrokontroler RP2040 (produkowane również przez Raspberry Pi Foundation)
			\item \textit{Cortex M0+}
			\item PWM
			\item DMA
			\item PIO
			\item DAC
			\item \isqs{} proto
			\item PCM
			\item SIO
%			TODO fill in dict
		\end{itemize}
	
	\chapter{Projekt interfejsu i interakcji z użytkownikiem}
	W rozdziale drugim skupiono się na aspektach funkcjonalności produktu jak i projekcje interakcji z użytkownikiem.\\
	
	Najważniejszym elementem planowania projektu z perspektywy użyteczności dla klienta jest plan wygodnego i intuicyjnego interfejsu użytkownika. Dodatkową komplikacją jest fakt, że urządzenie będzie miało do dyspozycji tylko niewielki wyświetlacz i kilka przycisków. Należy więc zadbać, żeby przy tym niewielkim asortymencie sprzętu dało się przekazać wszystkie informacje i ustalić co użytkownik planuje zrobić w następnej kolejności.
		
	\section{Projekt interfejsu}
		Do zaprojektowania ekranów posłużyło narzędzie Figma\textsuperscript{\cite{figma}}. Na rysunku~\ref{2/interface/all} przedstawiono jak wyglądają poszczególne okna oraz jak użytkownik może przemieszczać się  pomiędzy nimi. Na rysunkach \ref{2/interface/real1} oraz \ref{2/interface/real2} umieszczono zdjęcia interfejsu na rzeczywistym wyświetlaczu.
		
		\paragraph{Ikony statusu}
			Przy projektowaniu interfejsów poczyniono założenie, że ikony statusowe (połączenie WiFi/włożona karta SD/etc.) znajdować się będą na górze ekranu. Nie będą one klikalne.
			
		\paragraph{Ikony akcji}
			Na ekranach w dolnej części umieszczono ikony akcji. Jest to np. ikona wstecz lub wyszukaj. Użytkownik dzięki nim będzie mógł przeprowadzać dodatkowe akcje.
		
		$ $\\
		Przy wyświetlaniu listy (np. wyników wyszukiwania lub listy ulubionych stacji) kliknięcie w daną pozycję powoduje zaakceptowanie jej i otworzenie następnego ekranu.

		\imgcs{2/interface/all}{Przemieszczanie się pomiędzy ekranami}{0.9}
		\imgss{2/interface/real1}{Wyszukiwanie stacji}{2/interface/real2}{Wyniki wyszukiwania}
	
	\section{Interakcja z użytkownikiem}
		W trakcie projektowania ekranów konieczne stało się założenie użycia 5 przycisków. Cztery z nich zostaną użyte do nawigacji prawo/lewo/góra/dół, a pozostały (środkowy) do wykonania wybranej akcji. Poniżej przedstawione zostały wybrane scenariusze obsługi radia.
%		Nawigacja oparta jest na siatce przycisków, przy czym może być ona nieregularna (różna liczba przycisków w różnych wierszach). 
		
		\imgh{2/btn/1}{Krok w dół na liście}{0.7}
		Na rysunku~\ref{2/btn/1} widać jak użytkownik aby poruszyć się w dół listy stacji naciska dolny przycisk. Powrót do \textit{Radio 1} jest oczywiście możliwy poprzez naciśnięcie górnego przycisku.
		
		\imgh{2/btn/2}{Przewinięcie listy stacji do góry}{0.7}
		Po dojściu do czwartej pozycji na liście, jeżeli na liście jest więcej niż 4 stacje, po naciśnięciu dolnego przycisku, zgodne z rysunkiem~\ref{2/btn/2}, kursor zostanie przeniesiony do piątej stacji. Należy zwrócić uwagę na zmianę położenia paska przewijania (po prawej stronie).
		
		\imgh{2/btn/3}{Przejście z listy do ikon akcji}{0.7}
		Jeżeli wskaźnik znajduje się na końcu listy (pasek przewijania w skrajnie dolnej pozycji), po naciśnięciu przycisku w dół, kursor znajdzie się w pasku ikon akcji. Sytuację tę przedstawia rysunek \ref{2/btn/3}. Powrót na listę stacji jest możliwy przy pomocy górnego przycisku.
		
		\imghss{2/btn/4r}{Przejście w prawo}{2/btn/4l}{Przejście w lewo}
		Poruszanie się w obrębie jednego wiersza zostało zrealizowane poprzez przyciski \mbox{lewo/prawo}. Przedstawiają to rysunki \ref{2/btn/4r} i \ref{2/btn/4l} na przykładzie dwóch ikon akcji.
		
		\imgh{2/btn/5}{Akceptacja wyboru}{0.7}
		Przycisk środkowy służy do wykonania akcji. Jeżeli kursor jest ustawiony na liście, możemy rozpocząć odtwarzanie naciskając go (rysunek \ref{2/btn/5})
		
		\imghss{2/err1}{Błąd odtwarzania}{2/err2}{Błąd ładowania stacji z bazy danych}
		Czasami w komunikacji z serwerem może wystąpić błąd. Takie sytuacje są zgłaszane użytkownikowi poprzez ekrany błędów widoczne na rysunkach \ref{2/err1} i \ref{2/err2} (czerwone tło). Aby wyjść z takiego ekranu nacisnąć dowolny przycisk.
	
	\chapter{Wybrane aspekty realizacji}
	W tym rozdziale wyjaśnione zostało jak zbudowany został projekt.
	
	\section{Moduły projektu}
	W kodzie starano się zachować porządek. Wydzielone zostały główne funkcjonalne elementy i na podstawie tego podziału stworzona została struktura modularna przedstawiona na rysunku \ref{3/pico-radio-code-block-diagram}.
	\imgh{3/pico-radio-code-block-diagram}{Schemat blokowy modułów projektu}{0.7}
	
	\subsection{Moduły własne}
	Większość kodu projektu zawiera katalog \lstinline|libs|. W nim znajdują się poszczególne moduły (nazwane odpowiednimi nazwami podfolderów). Wszystkie wypisane w tej sekcji zostały zaimplementowane samodzielnie, chyba, że zaznaczono inaczej. Dla przejrzystości pogrupowano moduły wg ich ról.
	
	\paragraph{Wejście}
	\begin{itemize}
		\item \lstinline|analog| -- dostęp do pomiaru poziomu naładowania baterii
		\item \lstinline|buttons| -- funkcje do obsługi przycisków
		\item \lstinline|sd| -- wykrywanie i montowanie karty SD z systemem plików FAT
	\end{itemize}

	\paragraph{Wyjście}
	\begin{itemize}
		\item \lstinline|display| -- obsługa wyświetlacza
		\begin{itemize}
			\item \lstinline|assets| -- artefakty; takie jak czcionki i ikony
			\item \lstinline|screens| -- widoki użytkownika
			\item \lstinline|tft| -- niskopoziomowa obsługa ekranu ze sterownikiem ST7735s. Kod inicjalizacji i przesyłania pikseli zaczerpnięty z \textit{Adafruit-ST7735-Library}\textsuperscript{\cite{adafruit_st7735}}
		\end{itemize}
	\end{itemize}
	
	\paragraph{Obsługa list}
	\begin{itemize}
		\item \lstinline|list| -- obsługa list jak i ich ładowanie (wyszukiwanie/ulubione/listing plików na karcie SD)
	\end{itemize}
	
	\paragraph{Odtwarzanie}
	\begin{itemize}
		\item \lstinline|mcorefifo| -- funkcje pomocnicze do przesyłania komunikatów z rdzenia 1 do 0
		\item \lstinline|player| -- kontrola i odtwarzanie plików/strumieni internetowych
		\begin{itemize}
			\item \lstinline|decode| -- abstrakcje/implementacje dekodowania typów i odczytywania źródeł danych
			\item \lstinline|metadata| -- dekodowanie metadanych w różnych formatach audio
		\end{itemize}
	\end{itemize}

	\paragraph{Źródła danych}
	\begin{itemize}
		\item \lstinline|ds| -- interfejs \lstinline|DataSource| łączący różne źródła danych
		\item \lstinline|httpc| -- klient protokołu HTTP
		\item \lstinline|lfs| -- kod integrujący system plików LittleFS\textsuperscript{\cite{littlefs}}
	\end{itemize}

	\paragraph{Pliki pomocnicze}
	\begin{itemize}
		\item \lstinline|circularbuffer| -- bufor kołowy
		\item \lstinline|static| -- statycznie alokowane bufory
		\item \lstinline|util| -- funkcje pomocnicze
	\end{itemize}

	\subsection{Moduły zewnętrzne}
	W folderze \lstinline|libs/external| umieszczone zostały moduły dostarczone z zewnątrz:
	\begin{itemize}
		\item \lstinline|FreeRTOS-Kernel| -- jądro systemu czasu rzeczywistego FreeRTOS\textsuperscript{\cite{freertos_kernel}}
		\item \lstinline|helixmp3| -- biblioteka dekodująca format MP3\textsuperscript{\cite{helixmp3_repo}} oryginalnie napisana przez firmę \textit{RealNetworks}\textsuperscript{\cite{realnetworks}}
		\item \lstinline|littlefs| -- system plików LittleFS\textsuperscript{\cite{littlefs}}
		\item \lstinline|sd_lib| -- biblioteka FatFS\textsuperscript{\cite{fatfs}} wraz z kodem dostępu do karty SD\textsuperscript{\cite{sdfs}}
	\end{itemize}

	\section{Odtwarzanie dźwięku}
	Zanim radio urosło do rangi pracy inżynierskiej, było ono moim prywatnym projektem. Chciałem poznać mikrokontroler RP2040. Poznać \lstinline|pico-sdk|. Po pierwszym kontakcie na \textit{Systemach Wbudowanych} środowisko stworzone wokół przystępnej cenowo płytki Raspberry Pi Pico wydawało się ciekawe i interesujące. Mikrokontroler ten, bogato wyposażony, stanowił idealną podstawę do stworzenia czegoś, co zawsze chciałem zbudować: odtwarzacza dźwięku. Przy okazji, tworząc taki projekt mogłem zaznajomić się ze wszystkimi ważniejszymi peryferiami układu (wykorzystałem m.in. PWM, DMA, a także później).
	
	Szybko jednak okazało się, że odtwarzania dźwięku za pomocą wbudowanego układu PWM jest niewystarczające. Dźwięk był zbyt niskiej jakości aby nadawał się do odtwarzania muzyki. Wykorzystałem układ TDA1543 jako przetwornik cyfrowo-analogowy. Projekt odtwarzał tylko pliki WAV i wyglądał tak, jak na rysunku \ref{3/pr_wav}.
	
	Wtedy też wybrałem ten temat pracy inżynierskiej. Lecz zanim mogłem kontynuować, należało szybko zorientować się, czy płytka poradzi sobie z dekodowaniem formatu MP3 w czasie rzeczywistym. Dzięki bibliotece \lstinline|helixmp3| używającej arytmetyki stałoprzecinkowej, było to możliwe.
	
	\imgcs{3/pr_wav}{Projekt we wczesnych fazach rozwoju}{0.45}
	
	\subsection{Model przetwarzania dźwięku}
	
	\imgcs{3/pipeline}{Koncepcja wielowątkowego dekodowania}{0.8}
	
	Odtwarzanie dźwięku odbywa się za pomocą zewnętrznego przetwornika DAC. Mikrokontroler wysyła dźwięk w formacie PCM protokołem \isqs{} do specjalizowanego układu z wykorzystaniem DMA. Drugi rdzeń procesora wykorzystywany jest wyłącznie do dekompresji formatów audio.
	
%	TODO opisać tutaj co robi player.cpp (zmienna dec, funkcje publcizne)
	
	\subsection{Komunikacja z przetwornikiem}
	W programie zadeklarowany został bufor nieskompresowanego dźwięku PCM \lstinline|audio_pcm|. Ma on konfigurowalny rozmiar wyrażony w jednostkach 32-bitowych (2 kanały * 16-bitowa próbka). Przekazywany jest on do systemu DMA.
	
	\subsubsection{PIO}
		\imgcs{3/pio_block}{Pojedynczy blok PIO (dokumentacja RP2040\textsuperscript{\cite{pico_pdf}}, strona 309)}{0.7}
		\imgcs{3/pio_instr}{Zestaw instrukcji PIO (dokumentacja RP2040, strona 320)}{0.7}
		\imgcs{3/pio_i2s_docs}{Przebieg czasowy protokołu \isqs{} (dokumentacja TDA1543\textsuperscript{\cite{tda_pdf}}, strona 9)}{0.9}
		
		RP2040 posiada 8 programowalnych maszyn stanów, zgrupowanych w 2 bloki. W ramach jednego bloku (Rys. \ref{3/pio_block}) współdzielą one pamięć 32 instrukcji. Może wydawać się to mało, lecz instrukcje te są bardzo skondensowane.
		
		Język programowania to własnościowy język z rodziny assembler. Do środowiska \lstinline|pico-sdk| dołączony jest assembler \lstinline|picoasm|. Zestaw instrukcji przedstawiono na rysunku \ref{3/pio_instr}. Jak wspomniano wcześniej, instrukcje są skondensowane, to znaczy mogą wykonywać wiele operacji na raz. Na przykład opóźniać wykonanie programu lub ustawiać osobny rodzaj wyjść typu \sset{}.
		
		\paragraph{Wyjścia typu \sset{}}
			Jest to specjalny rodzaj wyjść, które mogą być ustawiane równocześnie z wykonywaniem innych instrukcji. Są szczególnie przydatne przy ustawianiu linii zegarowych i pozostałych linii kontrolnych. Minusem wykorzystania ustawiania wyjść \textit{na boku} jest konieczność poświęcenia możliwości opóźniania programu. W liście instrukcji pole \sset{} jest współdzielone z polem \lstinline|delay|. Jednak zaimplementowany program nie używa opóźnień.
		
		Instrukcja skoku obsługuje także dekrementację zmiennej w warunku. Same maszyny mogą mieć ustawiony dowolny adres wejścia i zapętlenia programu. Oszczędza to kilka instrukcji.
		$ $\\
		
		Dzięki tym blokom, możliwe jest dodanie do mikrokontrolera dowolnego protokołu danych bez zbytniego obciążenia procesora jego pełną symulacją. W ramach tej pracy został stworzony blok obsługi interfejsu \isqs{}, który serializuje dane dostarczane przez DMA i wysyła do układu DAC.
		
		Dokumentacja protokołu \isqs{} została zaczerpnięta z dokumentacji układu TDA1543. Przedstawia ją rysunek \ref{3/pio_i2s_docs}. Jak widać zmiana kanału (kodowanego poziomem linii \lstinline|WS|)  musi nastąpić przed wysłaniem ostatniego bitu poprzedniego kanału (\lstinline|LSB|, czyli \textit{Least Significant Bit}, najmniej znaczący bit kanału lewego). Z tego powodu program wydłużył się do 8 instrukcji. Niektóre układy obsługują protokół \textit{left-just}, który nie posiada tego ograniczenia, jednak z uwagi na niewystarczającą dokumentacje i małe wsparcie przez układy, wybrany został klasyczny \isqs{}.
		
		\begin{minipage}{\linewidth}
			\lstinputlisting[style=pio, caption={Kod programu \isqs{}}, label={3/pio_listing}]{lst/3/i2s.pio}
		\end{minipage}
		
		Kod tego bloku przedstawiony został na listingu \ref{3/pio_listing}. Poniżej omówione zostało jego działanie:
		\begin{itemize}
			\item Linia nr 3 ustawia ile bitów jest typu \lstinline|side-set|. Bity \lstinline|side-set| są wykorzystywane odpowiednio do: ustawienia linii \lstinline|WS| i linii \lstinline|BCK|.
			
			\item punktem wejścia programu jest linia nr 18. Ustawia ona liczbę powtórzeń i inicjalizuje linię \lstinline|WS| na 1 (kanał prawy) oraz linię \lstinline|BCK| na 1. Odwrócenie kolejności kanałów związane jest z kolejnością bajtów typu \textit{little-endian}). Następnie program automatycznie zapętla się do pierwszej instrukcji.
			
			\item Instrukcja \lstinline|out| powoduje wystawienie na linię \lstinline|DATA| jednego bitu z rejestru przesuwnego danych. \textit{Na boku} przełącza linię zegarową w stan niski
			
			\item Instrukcja \lstinline|jmp| najpierw sprawdza wartość rejestru \lstinline|X|. Jeżeli jest ona niezerowa to dekrementuje ją i skacze do etykiety \lstinline|right|. Pętla ta wykonuje się 15 razy.
			
			\item W linii nr 9 następuje transmisja najmniej znaczącego bitu kanału prawego. Zgodnie z dokumentacją musimy już zmienić stan linii \lstinline|WS| na 0 (kanał lewy). Następnie rejestr \lstinline|X| jest ponownie inicjalizowany na wartość 14.
			
			\item Linie 13-18 powtarzają transmisje zgodnie z opisem powyżej, ale tym razem dla kanału lewego.
		\end{itemize}
		
		Instrukcja \lstinline|out| czeka na dane w buforze automatycznie.
	
	\subsubsection{DMA}
		\imgcs{3/dma_chain}{Kolejkowanie kanałów DMA}{0.55}
		Podsystem bezpośredniego dostępu do pamięci wysyła dane do maszyn stanu PIO. Aby móc prowadzić nieprzerwaną transmisję, wykorzystane zostały dwa kanały z 12 dostępnych w układzie. Schemat działania przedstawiony został na rysunku \ref{3/dma_chain}. W momencie gdy jeden kanał skończy transfer, automatycznie uruchamiany jest drugi kanał. Taką funkcjonalność oferuje sprzętowo RP2040. Wywoływane jest także przerwanie, które zgłasza procesorowi potrzebę załadowania nowych danych. Ustawiają one flagi \lstinline|a_done_irq| i \lstinline|b_done_irq|.
		$ $\\
			
%		Rdzeń 0 obsługuje te przerwania. Bardziej korzystnym scenariuszem byłoby, gdyby to rdzeń 1 czekał na przerwanie instrukcją \lstinline|wfi| (\textit{wait-for-interrupt}), ponieważ nie ma on innych zadań. Jest to droga do dalszej opytmalizacji projektu.

	Wszystko to dzieje się na rdzeniu 0. Taka koncepcja pozwala na odtwarzanie nieskompresowanego dźwięku. Problem powstaje, gdy musimy w czasie rzeczywistym zdekodować nietrywialny format zapisu audio, np. MP3.
	
	\subsection{Dekompresja formatów}
	\imgh{3/rb_chart}{Udział kodeków w stacjach radiowych}{0.7}
	
	Wybór padł na format MP3. Jest on popularnym formatem zapisu skompresowanego dźwięku. Wg agregatu stacji radiowych \textit{Radio Browser}\textsuperscript{\cite{radio_browser_codecs}}, około 66\% wszystkich wpisów używa kodeku MP3 (w przypadku polskich stacji jest to około 60\%). Graficznie procentowe udziały przedstawia rysunek \ref{3/rb_chart}.
	
	\paragraph{Droga dalszego rozwoju}
	Najbardziej korzystną drogą rozwoju jest implementacja dekodowania AAC/AAC+. Na ten moment nie zostało to zrobione.
	$ $\\
	
	\subsubsection{Architektura programowa dekodera}
	\imgh{3/PicoRadio-sound-decoding}{Architektura dekodowania dźwięku}{0.95}
	
	Rysunek \ref{3/PicoRadio-sound-decoding} przedstawia w jaki sposób zorganizowane zostało odtwarzanie i dekodowanie dźwięku. Wszelkie interakcje z pozostałymi komponentami systemu obsługiwane są przez rdzeń 0, natomiast rdzeń 1 obsługuje dekodowanie formatów audio. Droga, jaką obrano, pozwala na łatwe rozszerzanie obsługiwanych formatów. Ważne jest tylko, aby pojedynczy rdzeń \textit{Cortex M0+} poradził sobie z obsłużeniem dekodowania nowego formatu w czasie rzeczywistym.
	
%	\paragraph{Flagi przerwań}
%	Jak wcześniej wspomniano, przerwania generowane przez kanały DMA ustawiają dwie flagi \lstinline|a_done_irq| lub \lstinline|b_done_irq|. Poprzez wspólną pamięć są one odczytywane przez rdzeń 1, a ten dekoduje dane i uzupełn

	\paragraph{Część Decode}
	Komponenty z tej rodziny odpowiedzialne są za dostarczanie nowych danych surowych (w kodzie \lstinline|raw_buf|(\textit{raw buffer}) lub \lstinline|cbuf| (\textit{content buffer})). Klasa bazowa \lstinline|DecodeBase| odpowiada za wspólne elementy obu źródeł danych. Obsługuje ona m.in. zunifikowane funkcje do wysyłania komunikatów o zakończeniu dekodowania, zużyciu danych z bufora, bądź błędach. Umożliwione zostało także odczytywanie statystyk i metadanych. Poszczególne klasy podrzędne skupiają się na dostarczaniu danych z różnych źródeł. \lstinline|DecodeFile| odpowiada za odczyt plików z karty SD, natomiast \lstinline|DecodeStream| odbiera dane ze strumienia internetowego.
	
	\paragraph{Część Format}
	Powstały interfejs \lstinline|Format| służy do abstrakcji dekodowania danych surowych. Jego główną metodą jest \lstinline|decode_up_to_n|, która dekoduje co najwyżej \lstinline|n| jednostek danych. Aby dowiedzieć się ile jednostek należy zdekodować istnieją funkcje \lstinline|units_to_decode_whole| i \lstinline|units_to_decode_half|, zwracające odpowiednio ile jednostek zapełni cały bufor \lstinline|audio_pcm| a ile pół bufora (taka liczba jest dekodowana po otrzymaniu przerwania od DMA, którego jeden kanał transferuje pół bufora). W przypadku formatu WAV jednostki to po prostu bajty, a gdy mówimy o MP3 będą to ramki. Podklasy implementują specjalizowane funkcje do dekodowania poszczególnych formatów.
	
	\paragraph{Bufor FIFO}
	RP2040 posiada wbudowane dwa bufory FIFO do komunikacji między rdzeniami. Jeden z rdzenia 0 do rdzenia 1, drugi w przeciwnym kierunku. Wykorzystany został bufor w kierunku $1 \rightarrow 0$ do przekazywania informacji o stanie dekodowania. Zaimplementowany został moduł \lstinline|mcorefifo| do wysyłania abstrakcyjnych wiadomości. Wykorzystuje on przerwanie SIO do odbioru komunikatów, a następnie przekazuje je do zarejestrowanego odbiorcy. Jednym z takich odbiorców jest moduł odtwarzacza, który w pliku \lstinline|decodebase.cpp| odbiera komunikaty o identyfikatorze \lstinline|PLAYER| w funkcji \lstinline|player_msg()| i przekazuje do swojej głównej pętli w funkcji \lstinline|play()|.
	
	\subsubsection{Biblioteka \textit{helixmp3}}
	Do dekodowania formatu MP3 wykorzystana została biblioteka \lstinline|helixmp3|. Opiera się ona na arytmetyce stałoprzecinkowej. Oryginalnie napisana przez \textit{RealNetworks}\textsuperscript{\cite{realnetworks}} w 2003 roku, znaleziona została w internecie pod postacią repozytoria GitHub\textsuperscript{\cite{helixmp3_repo}}. Do tej biblioteki dodana została obsługa RP2040 jak również integracja ze środowiskiem CMake. Jest to pierwszy wynik w wyszukiwarce Google (fraza \textit{mp3 decoding library fixed point}), dlatego poczynione ulepszenia, zostały zgłoszone autorowi repozytorium\textsuperscript{\cite{helixmp3_pr}}. Umożliwiona została także statyczna alokacja buforów na dane dekodera.
	
	Do biblioteki dekodującej odwołuje się tylko \lstinline|FormatMP3|, który funkcją \lstinline|decode_up_to_n|, dekoduje co najwyżej \lstinline|n| ramek MP3. Zwracana jest liczba zdekodowanych ramek. Jeżeli zdekoduje ich mniej, to znaczy, że odtwarzanie zakończyło się pomyślnie (np. koniec pliku). Jeżeli zwrócona zostanie wartość mniejsza od zera, oznacza to błąd. Jeżeli danych w buforze brakuje (np. niestabilna komunikacja sieciowa), rdzeń 1 czeka na dane w nieskończoność. Użytkownik jednak w każdej chwili może przerwać oczekiwanie.
	
	\subsection{Rozpoczynanie odtwarzania}
	\imgcs{3/PicoRadio-start}{Schemat procesu rozpoczynania odtwarzania}{0.7}
	Użytkownik rozpoczyna odtwarzanie poprzez wybranie pozycji z listy ulubionych lub wyszukanie stacji/wybór pliku na karcie SD. Dowolny widok może zainicjować ekran odtwarzania \lstinline|ScPlay|. Jednym z parametrów inicjalizacyjnych jest ścieżka dostępu. Gdy nastąpi zmiana aktywnego ekranu, wywoływana jest funkcja \lstinline|player_start()|. Więcej na temat widoków i zarządzania ekranem napisano w sekcji \ref{?}. % TODO uzupełnić ref
	
	\paragraph{Zadania systemu FreeRTOS}
		Funkcja \lstinline|player_start()| tworzy dwa osobne zadania w systemie operacyjnym, a sama kończy działanie od razu. Pierwsze z nich, \lstinline|player|, odpowiedzialne jest za uruchomienie procesu odtwarzania i przetwarzanie komunikatów (np. odnośnie konsumpcji bajtów z bufora czy wystąpienia błędów). Ładuje ono także dane do bufora z pliku. Drugie, pomocnicze zadanie \lstinline|player stat| służy do okresowego aktualizowania stanu odtwarzania na ekranie.
	
	\paragraph{Wykrywanie formatu}
		Format audio wykrywany jest na podstawie ścieżki do zasobu. Jeżeli ta zaczyna się od \lstinline|http|, zostanie użyta klasa \lstinline|DecodeStream| i \lstinline|FormatMP3|. Jeżeli początek nie dopasuje się do wzorca, przyjmowane jest odtwarzanie z pliku (klasa \lstinline|DecodeFile|) i na podstawie rozszerzenia pliku definiowane jest użycie klasy \lstinline|FormatWAV| lub \lstinline|FormatMP3|.
		
	\paragraph{Ograniczenia detekcji plików}
		Definicja formatu audio przebiega na samym początku co jest poważnym ograniczeniem i nie pozwala na zmianę formatu np. po odczytaniu nagłówka \lstinline|Content-type|. Jednak w obecnej formie projekt obsługuje tylko strumieniowanie plików MP3. Gdyby została dodana obsługa stacji AAC/AAC+ należałoby poprawić ten fragment kodu. Dodatkowo wtedy detekcja formatu plików lokalnych mogłaby zostać przeniesiona do \lstinline|DecodeFile|. Oprócz rozszerzeń, możliwa byłaby detekcja formatów plików na podstawie ich nagłówków. Pliki rozpoczynające się od \lstinline|http| zostaną potraktowane jako strumienie audio. Należy rozważyć użycie prefiksu \lstinline|file://| dla plików lokalnych.
	
	\paragraph{Możliwe błędy}
		Jeden z możliwych błędów występuje, gdy nie zostanie dopasowany żaden znany format audio. Należy wtedy zweryfikować czy pliki posiadają odpowiednie rozszerzenia, a strumienie sieciowe prefiks \lstinline|http|. Inny błąd oznacza że nie udało się rozpocząć odtwarzania, tzn. plik nie istnieje/nie można go odczytać lub serwer strumieniujący nie odpowiada lub też nie udało się określić jego adresu. Przedstawione poniżej zakańczanie odtwarzania nie uwzględnia tych błędów, ponieważ z punktu widzenia programu jeszcze się ono nie rozpoczęło.
	
	\subsection{Zatrzymywanie odtwarzania}
	\imgcs{3/PicoRadio-stop}{Schemat obsługi żądań zakończenia odtwarzania}{1}
	Zakończenie przetwarzania audio jest nietrywialnym procesem. Sygnał do zatrzymania może pochodzić z trzech różnych źródeł. Na rysunku~\ref{3/PicoRadio-stop} przedstawione zostały kolejne etapy obsługi tych sygnałów. Natomiast poniżej opisano skrótowo jak działa zgłaszanie poszczególnych kategorii zdarzeń. 
	$ $\\
	
	Parametrem funkcji \lstinline|DecodeBase::notify_playback_end(bool error)| jest flaga, która mówi, czy odtwarzanie zakończyło się błędem. Jeżeli jest ona ustawiona, to program wyświetli ekran błędu.
	
	\paragraph{Użytkownik}
		Użytkownik może zakończyć odtwarzanie poprzez naciśnięcie przycisku \textit{Wstecz} na ekranie odtwarzania. Podsystem wyświetlacza wywołuje wtedy funkcje \lstinline|player_stop()|, która rozpoczyna proces zakończenia odtwarzania i czeka aż rzeczywiście się ono zakończy. Ustawiana jest flaga \lstinline|abort|, która powoduje, że wszystkie implementacje \lstinline|decode_up_to_n(int n)|, kończą dekodowanie natychmiast. Dekodowane jest mniej ramek niż zadane \lstinline|n|, co wykrywane jest przez program jako zakończenie odtwarzania.
	
	\paragraph{Koniec pliku}
		Gdy funkcja \lstinline|load_buffer()| w \lstinline|DecodeFile| napotka koniec pliku powiadamia o tym fakcie klasę nadrzędną wywołując \lstinline|notify_eof()|. Nie używa ona bezpośrednio funkcji \lstinline|notify_playback_end()|, ponieważ przy zakończeniu odtwarzania bufor może zawierać jeszcze do 4 sekund dźwięku (bufor 64kB, format MP3 128kbps). Dopiero gdy funkcja oczekiwania na dane wykryje że jest ich za mało, a w pliku nie ma więcej bajtów do odczytania, odtwarzanie jest zakańczane. Dzieje się to w analogiczny sposób jak w przypadku zakończenia go przez użytkownika: dekodowane jest mniej ramek audio.
	
	\paragraph{Błąd}
		Błędy modułu odtwarzacza mogą być dwojakie. Błąd sieciowy występuje przy odtwarzaniu strumieni internetowych, np. radia. Biblioteka \textit{LWIP} zgłasza błąd, który poprzez \lstinline|notify_playback_end()| powoduje natychmiastowe zatrzymanie odtwarzania i wyświetlenie komunikatu o błędzie (flaga \lstinline|error| ustawiona na \lstinline|true|). Błąd odczytu z pliku występuje, gdy funkcja uzupełniająca bufor o dane z pliku zakończy się niepowodzeniem. Oznaczać to może na przykład że użytkownik usunął kartę SD z urządzenia lub wystąpił błąd komunikacji z nią. Analogicznie jak w przypadku błędu sieci odtwarzanie jest zakańczane natychmiast.
		
	\subsection{Metadane}
	Jednym z wymagań projektu było wyświetlanie aktualnie odtwarzanego utworu. Należało więc co najmniej zdekodować metadane wysyłane przez stacje radiowe. Dodatkowo, zostało zaimplementowane odczytywanie metadanych z plików MP3.
	
	\subsubsection{Stacje radiowe -- ICY}
		Szeroko stosowanym formatem przesyłania danych o utworach w strumieniach radiowych jest format ICY\textsuperscript{\cite{icy_spec}}. Klient może zażądać od serwera metadanych wysyłając do niego nagłówek \lstinline|Icy-Metadata: 1|. Serwer, jeżeli zaakceptował żądanie, odsyła nagłówek \lstinline|icy-metaint: <n>|. Jego wartość oznacza co ile bajtów strumienia będą wysyłane ramki z metadanymi. Zwykle \lstinline|<n>| jest równe 16000, co oznacza, że co każde odebrane 16000 bajtów wystąpią metadane. Jest to 1 sekunda dźwięku MP3 128kbps, czyli nazwy utworów będą aktualizowane raz na sekundę. Występuje też wartość 1000, co oznacza 16 aktualizacji w ciągu sekundy. Inne wartości są możliwe, ale nie są spotykane w praktyce.
		
		\paragraph{Abstrakcyjne położenie ramek ICY}
		Warto zaznaczyć, że miejsce wstawienia metadanych w żaden sposób nie uwzględnia formatu audio. Nie możemy zakładać że nie podzielą one jednej ramki MP3 na dwie części. Dla dźwięku MP3 128kbps ramka ma rozmiar 418 bajtów. Przy wartości \lstinline|icy-metaint| równej 16000, dane dźwiękowe będą podzielone co ok. $38.28$ ramki. Z tego powodu konieczne stało się obsługiwanie ramek ICY w momencie zapisu do bufora, zamiast przy jego odczycie. Odczyt obsługuje odpowiednia instancja \lstinline|Format|, która nie musi obsługiwać odczytywania ramek bajt po bajcie. Na przykład \lstinline|FormatMP3| nie obsługuje dekodowania ramek w częściach. Ramka MP3 musi znaleźć się w ciągłym obszarze pamięci, nie może być rozdzielona ramką ICY.
		$ $\\
		
		Funkcja \lstinline|DecodeStream::play()|, jeżeli dostępny jest nagłówek \lstinline|icy-metaint|, inicjalizuje odbierane danych metodą \lstinline|ICY::start()|. Następnie rejestruje odwołanie, które jest wywoływane po każdym zapisie do bufora oraz przetwarza już odebrane dane. W trakcie tych czynności blokowany jest kontekst biblioteki sieciowej, aby w trakcie przetwarzania danych nie zostały odebrane żadne nowe dane, a po odblokowaniu każde następne były wychwycone przez funkcję \lstinline|cbuf_write_cb()|.
		
		W każdym z tych scenariuszy (wstępne i późniejsze przetwarzanie) wywoływana jest w pętli funkcja \lstinline|ICY::read()|. Pętla jest potrzebna, ponieważ w porcji odebranych danych, szczególnie dla niskich wartości \lstinline|icy-metaint|, może wystąpić więcej niż jedna ramka ICY.
		
		\imgcs{3/PicoRadio-icy}{Ramka MP3 rozdzielona ramką ICY}{0.9}
		\paragraph{Format danych ICY}
			Nagłówek metadanych ICY składa się z jednego bajtu kodującego rozmiar danych (bez nagłówka) podzielony przez 16. Dane dopełniane są zerami do podanego rozmiaru. Wewnątrz ramki kolejne pola oddzielone są od siebie średnikami, a same pola są w formacie \lstinline|klucz='wartosc'|. Dekoder zaimplementowany w projekcie obsługuje tylko klucz \lstinline|StreamTitle|, którego wartość to zazwyczaj tytuł utworu i jego wykonawca. Ramka ICY została przedstawiona na rysunku~\ref{3/PicoRadio-icy}.
			$ $\\
			
		Wywołanie \lstinline|ICY::read()| kopiuje ramkę ICY z bufora audio do bufora tymczasowego, a następnie przesuwa dane za ramką wstecz o rozmiar ramki. Operację można porównać do wycinania tekstu z dokumentu tekstowego. W ten sposób przywracamy ciągłość ramce MP3. Dane w buforze tymczasowym nie są interpretowane aby zaoszczędzić cenny czas. Przypomnijmy, cała ta operacja odbywa się przy zablokowanej komunikacji sieciowej. Dane interpretowane są dopiero gdy zadanie \lstinline|player stat| wywoła \lstinline|DecodeBase::get_meta_str()|, która w implementacji \lstinline|DecodeStream| odwołuje się do metody \lstinline|ICY::get_stream_title()|. Funkcja ta blokuje mutex bufora tymczasowego i kopiuje dane do swojego buforu na stosie. Dopiero wtedy rozpoczyna potencjalnie kosztowną czasowo interpretację danych.
	
	\subsubsection{Lokalne pliki MP3 -- ID3v2}
		Tagowanie MP3 obsługiwane jest zupełnie różnie od ramek ICY. Mogą one występować na początku plików MP3. Sygnalizuje to fakt, że pliki te rozpoczynają się 3 bajtami równymi: \lstinline|I D 3|. Funkcje do obsługi tego typu tagowań zostały zaimplementowane w klasach pochodnych \lstinline|Format|. Wykorzystana została już wcześniej istniejąca funkcja \lstinline|Format::decode_header()|. Obsługiwała ona dekodowanie nagłówków WAVE. Wywoływana jest ona po pierwszym załadowaniu bufora, tylko raz na dany plik/strumień. Implementacja \lstinline|FormatMP3| wywołuje wtedy funkcję \lstinline|ID3::try_parse()|.
		
%		\paragraph{Format ramek ID3v2}
%		...
		%TODO opisać format ramek, jak są one czytane, które tagi obsługiwane
	
	\pagebreak
	\begin{thebibliography}{9}
		\bibitem{radio-browser}
		\href{https://www.radio-browser.info/}{\textit{Radio-browser} -- baza danych stacji radiowych}
		\bibitem{fmstream}
		\href{http://fmstream.org}{\textit{fmstream} -- baza danych stacji radiowych}
		
		\bibitem{minimp3}
		\href{https://github.com/lieff/minimp3}{\textit{minimp3} -- biblioteka dekodująca MP3}
		\bibitem{realnetworks}
		\href{https://realnetworks.com}{\textit{RealNetworks} -- firma odpowiedzialna za bibliotekę \textit{helixmp3}}
		\bibitem{helixmp3_repo}
		\href{https://github.com/ultraembedded/libhelix-mp3}{\textit{helixmp3} -- biblioteka dekodująca MP3 (napisana w 2003 roku przez RealNetworks)}
		
		\bibitem{rp2040}
		\href{https://www.raspberrypi.com/documentation/microcontrollers/rp2040.html}{\textit{RP2040} -- Mikrokontroler firmy Raspberry Pi}
		\bibitem{pico_sdk}
		\href{https://github.com/raspberrypi/pico-sdk}{\textit{pico-sdk} -- Zestaw bibliotek do Raspberry Pi Pico}
		\bibitem{freertos_kernel}
		\href{https://github.com/FreeRTOS/FreeRTOS-Kernel}{\textit{FreeRTOS Kernel} -- Jądro systemu czasu rzeczywistego FreeRTOS}
		\bibitem{adafruit_st7735}
		\href{https://github.com/adafruit/Adafruit-ST7735-Library}{\textit{Adafruit-ST7735-Library} -- biblioteka do obsługi ekranów LCD napisana przez firmę Adafruit}
		\bibitem{littlefs}
		\href{https://github.com/littlefs-project/littlefs}{\textit{LittleFS} -- System plików przeznaczony do pamięci flash}
		\bibitem{fatfs}
		\href{http://elm-chan.org/fsw/ff/00index_e.html}{\textit{FatFS} -- Obsługa systemów plików z rodziny FAT}
		\bibitem{sdfs}
		\href{https://github.com/carlk3/no-OS-FatFS-SD-SPI-RPi-Pico}{\textit{FatFS+SPI na Pi Pico} --  kompleksowa biblioteka łącząca FatFS i komunikację poprzez SPI z kartą SD (przystosowana do Pi Pico)}
		
		\bibitem{radio_adapter}
		\href{https://allegro.pl/oferta/adapter-radia-internetowego-dual-ir-3a-dab-fm-rds-12692108793}{\textit{Radio sieciowe} -- Sklep Allegro}
		\bibitem{radio_tanie}
		\href{https://www.x-kom.pl/p/653480-radio-internetowe-technisat-sternradio-ir-2-biale.html}{\textit{Radio internetowe mono} -- Sklep x-kom}
		\bibitem{radio_drogie}
		\href{https://www.x-kom.pl/p/724674-radio-internetowe-blaupunkt-ir10bt.html}{\textit{Radio internetowe stereo} -- Sklep x-kom}
		\bibitem{botland_stm}
		\href{https://botland.com.pl/stm32-discovery/4715-stm32f746g-disco-discovery-stm32f746ng-cortex-m7-ekran-dotykowy-pojemnosciowy-43--5904422374082.html}{\textit{STM32F746G-Disco} -- Sklep Botland}
		
		\bibitem{radio_pico1}
		\href{https://github.com/episource/picopdio}{\textit{picopdio} -- Przykładowe radio internetowe Raspberry Pi Pico}
		\bibitem{radio_vs1003}
		\href{https://botland.com.pl/odtwarzacze-mp3-wav-ogg-midi/14308-odtwarzacz-mp3-vs1003-z-mikrofonem-5903351241786.html}{\textit{VS1003} -- Sprzętowy dekoder MP3}
		
		\bibitem{figma}
		\href{https://www.figma.com}{\textit{Figma} -- Narzędzie do projektowania interfejsów}
		
		\bibitem{pico_pdf}
		\href{https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf}{\textit{RP2040 Datasheet} -- dokumentacja techniczna procesora RP2040}
		\bibitem{tda_pdf}
		\href{http://www.lampizator.eu/lampizator/LINKS%20AND%20DOWNLOADS/DATAMINING/tda%201543.pdf}{\textit{TDA1543 Datasheet} -- dokumentacja techniczna układu DAC TDA1543}
		
		\bibitem{radio_browser_codecs}
		\href{https://www.radio-browser.info/codecs}{\textit{Radio browser codecs} -- kodeki audio wylistowane na stronie Radio Browser}
		\bibitem{helixmp3_pr}
		\href{https://github.com/ultraembedded/libhelix-mp3/pull/3}{\textit{helixmp3 pull request} -- ulepszenia biblioteki dekodującej}
		
		\bibitem{icy_spec}
		\href{https://gist.github.com/niko/2a1d7b2d109ebe7f7ca2f860c3505ef0#file-icy_meta-md}{\textit{ICY} -- protokół przesyłania metadanych}
		
	\end{thebibliography}
	
\end{document}
