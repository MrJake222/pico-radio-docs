% !TeX spellcheck = pl_PL
\documentclass[12pt]{report}

\usepackage{amssymb} % symbol kąta
\usepackage[polish]{babel} % polskie nazwy
\usepackage[T1]{fontenc} % polskie znaki
\usepackage[margin=1.0in]{geometry} % marginesy
\usepackage[utf8]{inputenc}
\usepackage{listingsutf8} % bloki kodu
\usepackage{lmodern} % font
\usepackage{color} % kolory
\usepackage{indentfirst} % wcięcie w pierwszej linii paragrafu
\usepackage{graphicx} % obrazy
\usepackage{float} % dla image [H]
\usepackage{amsmath,amsthm,amssymb,mathtools} % matematyka dowód
\usepackage{changepage} % matematyka dowód
\usepackage{siunitx} % wyrównanie do kropki
\usepackage{makecell} % wyrównania nagłówków
\usepackage{hyperref} % bez obwódek wokół linków
\hypersetup{
	colorlinks,
	citecolor=black,
	filecolor=black,
	linkcolor=black,
	urlcolor=magenta
}
\usepackage{caption} % link przenosi do góry obrazka

% bez odstępu w itemize
\let\tempone\itemize
\let\temptwo\enditemize
\renewenvironment{itemize}{\tempone\setlength{\itemsep}{0cm}}{\temptwo}

\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}  

% Obrazki
% ścieżki do obrazków
\graphicspath{ {img/} }

% obrazek {nazwa.png}{opis}{rozmiar}{H - wymuszanie}
\newcommand{\imgint}[4]{
	\begin{figure}[{#4}]
		\centering
		\includegraphics[width=#3\textwidth]{#1}
		\caption{#2}
		\label{#1}
	\end{figure}
}

% obrazek {nazwa.png}{opis}{rozmiar} (bez wymuszania)
\newcommand{\imgcs}[3]{\imgint{#1}{#2}{#3}{}}

% obrazek {nazwa.png}{opis} (domyślny rozmiar)
\newcommand{\img}[2]{\imgcs{#1}{#2}{0.7}}

% obrazek {nazwa.png}{opis}{rozmiar} (wymuszona pozycja)
\newcommand{\imgh}[3]{\imgint{#1}{#2}{#3}{H}}

% dwa obrazki {1}{opis 1}{2}{opis 2}{H - wymuszanie}
\newcommand{\imgintss}[5]{
	\begin{figure}[{#5}]
		\centering
		\begin{minipage}{.45\textwidth}
			\centering
			\includegraphics[width=1\linewidth]{#1}
			\caption{#2}
			\label{#1}
		\end{minipage}%
		\hfill
		\begin{minipage}{.45\textwidth}
			\centering
			\includegraphics[width=1\linewidth]{#3}
			\caption{#4}
			\label{#3}
		\end{minipage}
	\end{figure}
}

% dwa obrazki {1}{opis 1}{2}{opis 2} (bez wymuszania)
\newcommand{\imgss}[4]{\imgintss{#1}{#2}{#3}{#4}{}}

% dwa obrazki {1}{opis 1}{2}{opis 2} (wymuszona pozycja)
\newcommand{\imghss}[4]{\imgintss{#1}{#2}{#3}{#4}{H}}

% tabela z wynikami {nazwa.txt}{opis}
\newcommand{\tab}[2]{
	\begin{table}
		\centering
		\caption{#2}
		\vspace{0.3cm}
		\input{#1}
	\end{table}
}

% nagłowek tabeli bold
\renewcommand\theadfont{\bfseries}

% interfejs I2S
\newcommand{\isqs}{$\text{I}^{2}\text{S}$}
% side-set
\newcommand{\sset}{\lstinline|side-set|}

\lstdefinestyle{pio}{
	basicstyle={\ttfamily \footnotesize},
	morekeywords={out, side, jmp, set},
	numbers=left,
	backgroundcolor=\color{lbcolor}
}

\begin{document}
	\lstset{inputencoding=utf8, basicstyle=\ttfamily}
	
	\title{Odbiornik internetowych stacji radiowych \\
		\vspace{0.2cm}
		\large Praca Inżynierska \\
		\large ...}
	\author{Norbert Morawski}
	
	\maketitle
	\tableofcontents
	\pagebreak
	
	\chapter{Cel prac i wizja produktu}
	W tym rozdziale opisano jak będzie wyglądał końcowy produkt. Zwrócono też uwagę na to jak będzie przebiegała jego realizacja i jakie ryzyka mogą wystąpić.
	
	\section{Opis problemu}
		Radio internetowe staje się co raz popularniejsze. Wolność transmisji, brak regulacji pasma radiowego powodują, że wiele niezależnych stacji radiowych wybiera właśnie to medium przekazu. Jednak większość funkcjonujących współcześnie odbiorników nie posiada funkcji odbioru strumienia internetowego. Celem pracy jest wykonanie kompletnego przenośnego urządzenia, które umożliwiłoby odbiór takich stacji.
		
	\section{Rola produktu}
		Radio jest skierowane do osób z małą wiedzą technologiczną. To znaczy, obsługa urządzenia powinna być prosta i intuicyjna. Nie powinny być wymagane żadne dodatkowe elementy do eksploatacji (zewnętrzne głośniki, specjalna ładowarka). Produkt ma być kompletnym urządzeniem gotowym do odbioru radia. Całość będzie zamknięta w obudowie. Na rysunku~\ref{1/radio_proj_trimmed} przedstawiony został projekt wizualny radia. Rysunek~\ref{1/PicoRadio_blocks} przedstawia uproszczony schemat blokowy urządzenia.
		
		\imgcs{1/radio_proj_trimmed}{Projekt wizualny radia (z zachowanymi proporcjami)}{0.9}
		\imgcs{1/PicoRadio_blocks}{Schemat blokowy radia}{1}
		
	\section{Współpracujące systemy}
		Oczywistym współpracującym systemem jest w przypadku tego projektu serwer strumieniujący radio internetowe. Standardem kodowania wykorzystywanym przez serwery jest format MP3 lub AAC/AAC+. Drugim współpracującym systemem jest baza danych zawierająca stacje radiowe. Baza taka powinna umożliwiać zapytania poprzez udokumentowane i dostępne API. List baz brana pod uwagę przy projektowaniu urządzenia:
		\begin{itemize}
			\item Radio-browser\textsuperscript{\cite{radio-browser}}
			\item fmstream\textsuperscript{\cite{fmstream}}
		\end{itemize}
		
		Druga baza, choć obszerniejsza (86,000 a 38,578 stacji), nie udostępnia interfejsu dla wszystkich. Autor życzy sobie osobistej prośby o dostęp, która na ten moment została wysłana i czeka na odpowiedź.
		
	\section{Wymagania}
		Główną funkcją budowanego urządzenia ma być możliwość odtwarzania radia internetowego.
		
		\subsection{Wymagane funkcjonalności}
			\begin{itemize}
				\item odtwarzanie stacji internetowych,
				\item wstrzymywanie odtwarzania,
				\item prezentacja na zintegrowanym wyświetlaczu aktualnego stanu,
				\item regulacja głośności odtwarzania,
				\item lista stacji,
				\item lista ulubionych stacji.
			\end{itemize}
			
			\paragraph{Dodatkowe funkcjonalności (niewymagane)}
			\begin{itemize}
				\item odtwarzanie plików z nośnika przenośnego,
			\end{itemize}
		
			\paragraph{Oczekiwany produkt}
			\begin{itemize}
				\item W pełni funkcjonalny prototyp urządzenia realizującego funkcje odbiornika internetowych stacji radiowych,
				\item Dokumentacja techniczna pozwalająca na zbudowanie urządzenia oraz rozwój jego oprogramowania układowego.
			\end{itemize}
		
		\subsection{Wymagania niefunkcjonalne}
			Urządzenie ma być wykonane z wykorzystaniem mikrokontrolera, lub płytki rozwojowej opartej o mikrokontroler. Rozwiązanie powinno obsługiwać połaczenie z Internetem, np. WiFi, do pobierania strumienia danych audio z serwera oraz musi poradzić sobie z dekodowaniem formatu MP3 lub AAC w czasie rzeczywistym.
			
			Zdecydowano się też na miniaturyzację wyświetlacza i zastosowanie do obsługi urządzenia kilku przycisków. Z uwagi na małą moc obliczeniową mikrokontrolera, regulacja głośności odbywać się będzie analogowym potencjometrem.
		
	\section{Przegląd konkurencyjnych rozwiązań}
		Ceny komercyjnych adapterów radia internetowego zaczynają się od ok. 330 zł za produkt powystawowy (Rysunek~\ref{1/radio_adapter}). Wieże z wbudowaną opcją radia internetowego to koszt rzędu 230 zł za najtańszy produkt z głośnikiem mono (Rysunek~\ref{1/radio_tanie}) lub ok. 370 zł za wersję stereo (Rysunek~\ref{1/radio_drogie}). Chciałbym mój produkt zrealizować kosztem przystępnym dla hobbystycznego amatora elektroniki. Wykluczam zatem użycie gotowych, drogich płytek rozwojowych, takich jak np. \textit{STM32F746G-Disco} kosztującej 389 zł (Rysunek~\ref{1/botland_stm}).
		
		Jednym z założeń pracy jest skonstruowanie systemu, którego dokumentacja pozwoli dowolnemu informatykowi/elektronikowi na skonstruowanie podobnego urządzenia i modyfikację jego oprogramowania. Projekt sam w sobie jest ciekawy ponieważ w Internecie mało jest prób konstrukcji radia internetowego opartego o Raspberry Pi Pico. Nie znaleziono żadnych projektów dekodujących samodzielnie format MP3.  Jeden z projektów\textsuperscript{\cite{radio_pico1}} używa sprzętowego dekodera MP3 (przedstawiony na rysunku~\ref{1/radio_mp3}). Większość odtwarzaczy własnej konstrukcji opiera się o pełnoprawny komputer jednopłytkowy Raspberry Pi, który jest obecnie trudno dostępny.
		
		Urządzenie będzie także posiadać prosty i intuicyjny interfejs, aby trafić do szerokiej grupy odbiorców. Zastosowane zostaną ogniwa ładowalne, tak, aby użytkownik przy pomocy np. portu USB mógł je naładować po wyczerpaniu.
		
		\img{1/radio_adapter}{Adapter radia internetowego \textsuperscript{\cite{radio_adapter}}}
		\imgss{1/radio_tanie}{Radio internetowe mono \textsuperscript{\cite{radio_tanie}}}{1/radio_drogie}{Radio internetowe stereo \textsuperscript{\cite{radio_drogie}}}
		
		\img{1/botland_stm}{Droga płytka STM\textsuperscript{\cite{botland_stm}}}
		
		\img{1/radio_mp3}{Sprzętowy dekoder MP3 \textsuperscript{\cite{radio_vs1003}}}
		
	\section{Analiza technologiczna}
		Do realizacji projektu wybrany został bogato wyposażony mikrokontroler Raspberry Pi RP2040\textsuperscript{\cite{rp2040}}. Jednak pojawiły się obawy o możliwość dekodowania formatu MP3 w czasie rzeczywistym.
		
		\subsection{Biblioteka dekodująca}
			Standardowa ramka MP3 odtwarzana jest przez ok. 26ms. Początkowe testy z biblioteką \lstinline|minimp3|\textsuperscript{\cite{minimp3}} do dekodowania formatu MP3 nie przyniosły obiecujących rezultatów.  Przy użyciu tej biblioteki ramka była dekodowana w 90ms. Jednak wykorzystanie \lstinline|helixmp3|\textsuperscript{\cite{helixmp3}} pozwoliło na zdekodowanie ramki w 22ms (80\% dostępnego czasu) przy domyślnym taktowaniu procesora.  Używa ona matematyki stałoprzecinkowej, co w przypadku jednostki bez koprocesora matematycznego stanowi dużą przewagę.
			
			Martwiące może się wydawać poświęcenie 80\% czasu procesora na dekodowanie formatu, jednak jako że mikrokontroler jest dwurdzeniowy, cały jeden rdzeń może zostać wykorzystany do dekodowania.
		
		\subsection{Oprogramowanie}
			Oprogramowanie zostanie napisane w języku C++ z wykorzystaniem środowiska \lstinline|pico-sdk|\textsuperscript{\cite{pico_sdk}}.  W środowisko brak wbudowanego centralnego systemu zarządzającego przepływem informacji oraz zadaniami, zatem do projektu dołączone zostało jądro systemu czasu rzeczywistego FreeRTOS\textsuperscript{\cite{freertos_kernel}}
	
	\section{Ryzyko}
		Należy uwzględnić ryzyko opóźnień w ustalonym trybie prac. Tworzenie oprogramowania wiąże się z ryzykiem dotarcia w ślepy zaułek i konieczności gruntownego przeprojektowania części systemów. Dostosowanie platformy pod centralny system czasu rzeczywistego stanowi przykład takiego opóźnienia. Posiadając jedną płytkę Raspberry Pi Pico, jej uszkodzenie również może powodować opóźnienia w realizacji projektu. Warto zaopatrzyć się w więcej niż jedną sztukę krytycznych elementów. Niespodziewane problemy z jakością oprogramowania, takie jak na przykład ciężko reprodukowalne błędy w strumieniowaniu audio, także mogą przyczynić się do wielu godzin poszukiwania przyczyn takiego zachowania aplikacji.
		Dobre planowanie, rzetelne projektowanie i tworzenie aplikacji powinny umniejszyć rolę w.w. ryzyk.
	
	\section{Słownik pojęć}
		\begin{itemize}
%			\item MP3 (\textit{MPEG-1 Audio Layer 3}) -- popularny format zapisu dźwięku; implementuje stratną kompresję,
			\item AAC/AAC+ (\textit{Advanced Audio Coding}) -- inny format dźwięku z kompresją stratną
%			\item Li-ion -- akumulatory Litowo-jonowe (ładowalne)
			\item Raspberry Pi -- komputery jednopłytkowe tworzone przez Raspberry Pi Foundation
			\item Raspberry Pi Pico -- płytki rozwojowe oparte o mikrokontroler RP2040 (produkowane również przez Raspberry Pi Foundation)
			\item \textit{Cortex M0+}
			\item PWM
			\item DMA
			\item PIO
			\item DAC
			\item \isqs{} proto
			\item PCM
			\item SIO
			\item TCP
			\item TLS
%			TODO fill in dict
		\end{itemize}
	
	\chapter{Projekt interfejsu i interakcji z użytkownikiem}
	W rozdziale drugim skupiono się na aspektach funkcjonalności produktu jak i projekcje interakcji z użytkownikiem.\\
	
	Najważniejszym elementem planowania projektu z perspektywy użyteczności dla klienta jest plan wygodnego i intuicyjnego interfejsu użytkownika. Dodatkową komplikacją jest fakt, że urządzenie będzie miało do dyspozycji tylko niewielki wyświetlacz i kilka przycisków. Należy więc zadbać, żeby przy tym niewielkim asortymencie sprzętu dało się przekazać wszystkie informacje i ustalić co użytkownik planuje zrobić w następnej kolejności.
		
	\section{Projekt interfejsu}
		Do zaprojektowania ekranów posłużyło narzędzie Figma\textsuperscript{\cite{figma}}. Na rysunku~\ref{2/interface/all} przedstawiono jak wyglądają poszczególne okna oraz jak użytkownik może przemieszczać się  pomiędzy nimi. Na rysunkach \ref{2/interface/real1} oraz \ref{2/interface/real2} umieszczono zdjęcia interfejsu na rzeczywistym wyświetlaczu.
		
		\paragraph{Ikony statusu}
			Przy projektowaniu interfejsów poczyniono założenie, że ikony statusowe (połączenie WiFi/włożona karta SD/etc.) znajdować się będą na górze ekranu. Nie będą one klikalne.
			
		\paragraph{Ikony akcji}
			Na ekranach w dolnej części umieszczono ikony akcji. Jest to np. ikona wstecz lub wyszukaj. Użytkownik dzięki nim będzie mógł przeprowadzać dodatkowe akcje.
		
		$ $\\
		Przy wyświetlaniu listy (np. wyników wyszukiwania lub listy ulubionych stacji) kliknięcie w daną pozycję powoduje zaakceptowanie jej i otworzenie następnego ekranu.

		\imgcs{2/interface/all}{Przemieszczanie się pomiędzy ekranami}{0.9}
		\imgss{2/interface/real1}{Wyszukiwanie stacji}{2/interface/real2}{Wyniki wyszukiwania}
	
	\section{Interakcja z użytkownikiem}
		W trakcie projektowania ekranów konieczne stało się założenie użycia 5 przycisków. Cztery z nich zostaną użyte do nawigacji prawo/lewo/góra/dół, a pozostały (środkowy) do wykonania wybranej akcji. Poniżej przedstawione zostały wybrane scenariusze obsługi radia.
%		Nawigacja oparta jest na siatce przycisków, przy czym może być ona nieregularna (różna liczba przycisków w różnych wierszach). 
		
		\imgh{2/btn/1}{Krok w dół na liście}{0.7}
		Na rysunku~\ref{2/btn/1} widać jak użytkownik aby poruszyć się w dół listy stacji naciska dolny przycisk. Powrót do \textit{Radio 1} jest oczywiście możliwy poprzez naciśnięcie górnego przycisku.
		
		\imgh{2/btn/2}{Przewinięcie listy stacji do góry}{0.7}
		Po dojściu do czwartej pozycji na liście, jeżeli na liście jest więcej niż 4 stacje, po naciśnięciu dolnego przycisku, zgodne z rysunkiem~\ref{2/btn/2}, kursor zostanie przeniesiony do piątej stacji. Należy zwrócić uwagę na zmianę położenia paska przewijania (po prawej stronie).
		
		\imgh{2/btn/3}{Przejście z listy do ikon akcji}{0.7}
		Jeżeli wskaźnik znajduje się na końcu listy (pasek przewijania w skrajnie dolnej pozycji), po naciśnięciu przycisku w dół, kursor znajdzie się w pasku ikon akcji. Sytuację tę przedstawia rysunek \ref{2/btn/3}. Powrót na listę stacji jest możliwy przy pomocy górnego przycisku.
		
		\imghss{2/btn/4r}{Przejście w prawo}{2/btn/4l}{Przejście w lewo}
		Poruszanie się w obrębie jednego wiersza zostało zrealizowane poprzez przyciski \mbox{lewo/prawo}. Przedstawiają to rysunki \ref{2/btn/4r} i \ref{2/btn/4l} na przykładzie dwóch ikon akcji.
		
		\imgh{2/btn/5}{Akceptacja wyboru}{0.7}
		Przycisk środkowy służy do wykonania akcji. Jeżeli kursor jest ustawiony na liście, możemy rozpocząć odtwarzanie naciskając go (rysunek \ref{2/btn/5})
		
		\imghss{2/err1}{Błąd odtwarzania}{2/err2}{Błąd ładowania stacji z bazy danych}
		Czasami w komunikacji z serwerem może wystąpić błąd. Takie sytuacje są zgłaszane użytkownikowi poprzez ekrany błędów widoczne na rysunkach \ref{2/err1} i \ref{2/err2} (czerwone tło). Aby wyjść z takiego ekranu nacisnąć dowolny przycisk.
	
	\chapter{Wybrane aspekty realizacji}
	W tym rozdziale wyjaśnione zostało jak zbudowany został projekt.
	
	\section{Moduły projektu}
	W kodzie starano się zachować porządek. Wydzielone zostały główne funkcjonalne elementy i na podstawie tego podziału stworzona została struktura modularna przedstawiona na rysunku \ref{3/pico-radio-code-block-diagram}.
	\imgh{3/pico-radio-code-block-diagram}{Schemat blokowy modułów projektu}{0.7}
	
	\subsection{Moduły własne}
	Większość kodu projektu zawiera katalog \lstinline|libs|. W nim znajdują się poszczególne moduły (nazwane odpowiednimi nazwami podfolderów). Wszystkie wypisane w tej sekcji zostały zaimplementowane samodzielnie, chyba, że zaznaczono inaczej. Dla przejrzystości pogrupowano moduły wg ich ról.
	
	\paragraph{Wejście}
	\begin{itemize}
		\item \lstinline|analog| -- dostęp do pomiaru poziomu naładowania baterii
		\item \lstinline|buttons| -- funkcje do obsługi przycisków
		\item \lstinline|sd| -- wykrywanie i montowanie karty SD z systemem plików FAT
	\end{itemize}

	\paragraph{Wyjście}
	\begin{itemize}
		\item \lstinline|display| -- obsługa wyświetlacza
		\begin{itemize}
			\item \lstinline|assets| -- artefakty; takie jak czcionki i ikony
			\item \lstinline|screens| -- widoki użytkownika
			\item \lstinline|tft| -- niskopoziomowa obsługa ekranu ze sterownikiem ST7735s. Kod inicjalizacji i przesyłania pikseli zaczerpnięty z \textit{Adafruit-ST7735-Library}\textsuperscript{\cite{adafruit_st7735}}
		\end{itemize}
	\end{itemize}
	
	\paragraph{Obsługa list}
	\begin{itemize}
		\item \lstinline|list| -- obsługa list jak i ich ładowanie (wyszukiwanie/ulubione/listing plików na karcie SD)
	\end{itemize}
	
	\paragraph{Odtwarzanie}
	\begin{itemize}
		\item \lstinline|mcorefifo| -- funkcje pomocnicze do przesyłania komunikatów z rdzenia 1 do 0
		\item \lstinline|player| -- kontrola i odtwarzanie plików/strumieni internetowych
		\begin{itemize}
			\item \lstinline|decode| -- abstrakcje/implementacje dekodowania typów i odczytywania źródeł danych
			\item \lstinline|metadata| -- dekodowanie metadanych w różnych formatach audio
		\end{itemize}
	\end{itemize}

	\paragraph{Źródła danych}
	\begin{itemize}
		\item \lstinline|ds| -- interfejs \lstinline|DataSource| łączący różne źródła danych
		\item \lstinline|httpc| -- klient protokołu HTTP
		\item \lstinline|lfs| -- kod integrujący system plików LittleFS\textsuperscript{\cite{littlefs}}
	\end{itemize}
	
	\paragraph{Wi-Fi}
	\begin{itemize}
		\item \lstinline|wifi| -- obsługa sieci bezprzewodowych
	\end{itemize}

	\paragraph{Pliki pomocnicze}
	\begin{itemize}
		\item \lstinline|circularbuffer| -- bufor kołowy
		\item \lstinline|static| -- statycznie alokowane bufory
		\item \lstinline|util| -- funkcje pomocnicze
	\end{itemize}

	\subsection{Moduły zewnętrzne}
	W folderze \lstinline|libs/external| umieszczone zostały moduły dostarczone z zewnątrz:
	\begin{itemize}
		\item \lstinline|FreeRTOS-Kernel| -- jądro systemu czasu rzeczywistego FreeRTOS\textsuperscript{\cite{freertos_kernel}}
		\item \lstinline|helixmp3| -- biblioteka dekodująca format MP3\textsuperscript{\cite{helixmp3_repo}} oryginalnie napisana przez firmę \textit{RealNetworks}\textsuperscript{\cite{realnetworks}}
		\item \lstinline|littlefs| -- system plików LittleFS\textsuperscript{\cite{littlefs}}
		\item \lstinline|sd_lib| -- biblioteka FatFS\textsuperscript{\cite{fatfs}} wraz z kodem dostępu do karty SD\textsuperscript{\cite{sdfs}}
	\end{itemize}

	\section{Odtwarzanie dźwięku}
	Zanim radio urosło do rangi pracy inżynierskiej, było ono moim prywatnym projektem. Chciałem poznać mikrokontroler RP2040. Poznać \lstinline|pico-sdk|. Po pierwszym kontakcie na \textit{Systemach Wbudowanych} środowisko stworzone wokół przystępnej cenowo płytki Raspberry Pi Pico wydawało się ciekawe i interesujące. Mikrokontroler ten, bogato wyposażony, stanowił idealną podstawę do stworzenia czegoś, co zawsze chciałem zbudować: odtwarzacza dźwięku. Przy okazji, tworząc taki projekt mogłem zaznajomić się ze wszystkimi ważniejszymi peryferiami układu (wykorzystałem m.in. PWM, DMA, a także później PIO).
	
	Szybko jednak okazało się, że odtwarzania dźwięku za pomocą wbudowanego układu PWM jest niewystarczające. Dźwięk był zbyt niskiej jakości aby nadawał się do odtwarzania muzyki. Wykorzystałem układ TDA1543 jako przetwornik cyfrowo-analogowy. Projekt odtwarzał tylko pliki WAV i wyglądał tak, jak na rysunku \ref{3/pr_wav}.
	
	Wtedy też wybrałem ten temat pracy inżynierskiej. Lecz zanim mogłem kontynuować, należało szybko zorientować się, czy płytka poradzi sobie z dekodowaniem formatu MP3 w czasie rzeczywistym. Dzięki bibliotece \lstinline|helixmp3| używającej arytmetyki stałoprzecinkowej, było to możliwe.
	
	\imgcs{3/pr_wav}{Projekt we wczesnych fazach rozwoju}{0.45}
	
	\subsection{Model przetwarzania dźwięku}
	
	\imgcs{3/pipeline}{Koncepcja wielowątkowego dekodowania}{0.8}
	
	Odtwarzanie dźwięku odbywa się za pomocą zewnętrznego przetwornika DAC. Mikrokontroler wysyła dźwięk w formacie PCM protokołem \isqs{} do specjalizowanego układu z wykorzystaniem DMA. Drugi rdzeń procesora wykorzystywany jest wyłącznie do dekompresji formatów audio.
	
%	TODO opisać tutaj co robi player.cpp (zmienna dec, funkcje publcizne)
	
	\subsection{Komunikacja z przetwornikiem}
	W programie utworzony został bufor nieskompresowanego dźwięku PCM \lstinline|audio_pcm|. Ma on konfigurowalny rozmiar wyrażony w jednostkach 32-bitowych (2 kanały * 16-bitowa próbka). Przekazywany jest on do systemu DMA.
	
	\subsubsection{PIO}
		\imgcs{3/pio_block}{Pojedynczy blok PIO (dokumentacja RP2040\textsuperscript{\cite{pico_pdf}}, strona 309)}{0.7}
		\imgcs{3/pio_instr}{Zestaw instrukcji PIO (dokumentacja RP2040, strona 320)}{0.7}
		\imgcs{3/pio_i2s_docs}{Przebieg czasowy protokołu \isqs{} (dokumentacja TDA1543\textsuperscript{\cite{tda_pdf}}, strona 9)}{0.9}
		
		RP2040 posiada 8 programowalnych maszyn stanów, zgrupowanych w 2 bloki. W ramach jednego bloku (Rys. \ref{3/pio_block}) współdzielą one pamięć 32 instrukcji. Może wydawać się to mało, lecz instrukcje te są bardzo skondensowane.
		
		Język programowania to własnościowy język z rodziny assembler. Do środowiska \lstinline|pico-sdk| dołączony jest assembler \lstinline|picoasm|. Zestaw instrukcji przedstawiono na rysunku \ref{3/pio_instr}. Jak wspomniano wcześniej, instrukcje są skondensowane, to znaczy mogą wykonywać wiele operacji na raz. Na przykład opóźniać wykonanie programu lub ustawiać osobny rodzaj wyjść typu \sset{}.
		
		\paragraph{Wyjścia typu \sset{}}
			Jest to specjalny rodzaj wyjść, które mogą być ustawiane równocześnie z wykonywaniem innych instrukcji. Są szczególnie przydatne przy ustawianiu linii zegarowych i pozostałych linii kontrolnych. Minusem wykorzystania ustawiania wyjść \textit{na boku} jest konieczność poświęcenia możliwości opóźniania programu. W liście instrukcji pole \sset{} jest współdzielone z polem \lstinline|delay|. Jednak zaimplementowany program nie używa opóźnień.
		
		Instrukcja skoku obsługuje także dekrementację zmiennej w warunku. Same maszyny mogą mieć ustawiony dowolny adres wejścia i zapętlenia programu. Oszczędza to kilka instrukcji.
		$ $\\
		
		Dzięki tym blokom, możliwe jest dodanie do mikrokontrolera dowolnego protokołu danych bez zbytniego obciążenia procesora jego pełną symulacją. W ramach tej pracy został stworzony blok obsługi interfejsu \isqs{}, który serializuje dane dostarczane przez DMA i wysyła do układu DAC.
		
		Dokumentacja protokołu \isqs{} została zaczerpnięta z dokumentacji układu TDA1543. Przedstawia ją rysunek \ref{3/pio_i2s_docs}. Jak widać zmiana kanału (kodowanego poziomem linii \lstinline|WS|)  musi nastąpić przed wysłaniem ostatniego bitu poprzedniego kanału (\lstinline|LSB|, czyli \textit{Least Significant Bit}, najmniej znaczący bit kanału lewego). Z tego powodu program wydłużył się do 8 instrukcji. Niektóre układy obsługują protokół \textit{left-just}, który nie posiada tego ograniczenia, jednak z uwagi na niewystarczającą dokumentacje i małe wsparcie przez układy, wybrany został klasyczny \isqs{}.
		
		\begin{minipage}{\linewidth}
			\lstinputlisting[style=pio, caption={Kod programu \isqs{}}, label={3/pio_listing}]{lst/3/i2s.pio}
		\end{minipage}
		
		Kod tego bloku przedstawiony został na listingu \ref{3/pio_listing}. Poniżej omówione zostało jego działanie:
		\begin{itemize}
			\item Linia nr 3 ustawia ile bitów jest typu \lstinline|side-set|. Bity \lstinline|side-set| są wykorzystywane odpowiednio do: ustawienia linii \lstinline|WS| i linii \lstinline|BCK|.
			
			\item punktem wejścia programu jest linia nr 18. Ustawia ona liczbę powtórzeń i inicjalizuje linię \lstinline|WS| na 1 (kanał prawy) oraz linię \lstinline|BCK| na 1. Odwrócenie kolejności kanałów związane jest z kolejnością bajtów typu \textit{little-endian}). Następnie program automatycznie zapętla się do pierwszej instrukcji.
			
			\item Instrukcja \lstinline|out| powoduje wystawienie na linię \lstinline|DATA| jednego bitu z rejestru przesuwnego danych. \textit{Na boku} przełącza linię zegarową w stan niski
			
			\item Instrukcja \lstinline|jmp| najpierw sprawdza wartość rejestru \lstinline|X|. Jeżeli jest ona niezerowa to dekrementuje ją i skacze do etykiety \lstinline|right|. Pętla ta wykonuje się 15 razy.
			
			\item W linii nr 9 następuje transmisja najmniej znaczącego bitu kanału prawego. Zgodnie z dokumentacją musimy już zmienić stan linii \lstinline|WS| na 0 (kanał lewy). Następnie rejestr \lstinline|X| jest ponownie inicjalizowany na wartość 14.
			
			\item Linie 13-18 powtarzają transmisje zgodnie z opisem powyżej, ale tym razem dla kanału lewego.
		\end{itemize}
		
		Instrukcja \lstinline|out| czeka na dane w buforze automatycznie.
	
	\subsubsection{DMA}
		\imgcs{3/dma_chain}{Kolejkowanie kanałów DMA}{0.55}
		Podsystem bezpośredniego dostępu do pamięci wysyła dane do maszyn stanu PIO. Aby móc prowadzić nieprzerwaną transmisję, wykorzystane zostały dwa kanały z 12 dostępnych w układzie. Schemat działania przedstawiony został na rysunku \ref{3/dma_chain}. W momencie gdy jeden kanał skończy transfer, automatycznie uruchamiany jest drugi kanał. Taką funkcjonalność oferuje sprzętowo RP2040. Wywoływane jest także przerwanie, które zgłasza procesorowi potrzebę załadowania nowych danych. Ustawiają one flagi \lstinline|a_done_irq| i \lstinline|b_done_irq|.
		$ $\\
			
%		Rdzeń 0 obsługuje te przerwania. Bardziej korzystnym scenariuszem byłoby, gdyby to rdzeń 1 czekał na przerwanie instrukcją \lstinline|wfi| (\textit{wait-for-interrupt}), ponieważ nie ma on innych zadań. Jest to droga do dalszej opytmalizacji projektu.

	Wszystko to dzieje się na rdzeniu 0. Taka koncepcja pozwala na odtwarzanie nieskompresowanego dźwięku. Problem powstaje, gdy musimy w czasie rzeczywistym zdekodować nietrywialny format zapisu audio, np. MP3.
	
	\subsection{Dekompresja formatów}
	\imgh{3/rb_chart_new}{Udział kodeków w stacjach radiowych}{0.9}
	
	Wybór padł na format MP3. Jest on popularnym formatem zapisu skompresowanego dźwięku. Wg agregatu stacji radiowych \textit{Radio Browser}\textsuperscript{\cite{radio_browser_codecs}}, około 66\% wszystkich wpisów używa kodeku MP3 (w przypadku polskich stacji jest to około 60\%). Graficznie procentowe udziały przedstawia rysunek \ref{3/rb_chart_new}.
	
	\paragraph{Droga dalszego rozwoju}
	Najbardziej korzystną drogą rozwoju jest implementacja dekodowania AAC/AAC+. Na ten moment nie zostało to zrobione.
	$ $\\
	
	\subsubsection{Architektura programowa dekodera}
	\imgh{3/PicoRadio-sound-decoding}{Architektura dekodowania dźwięku}{0.95}
	
	Rysunek \ref{3/PicoRadio-sound-decoding} przedstawia w jaki sposób zorganizowane zostało odtwarzanie i dekodowanie dźwięku. Wszelkie interakcje z pozostałymi komponentami systemu obsługiwane są przez rdzeń 0, natomiast rdzeń 1 obsługuje dekodowanie formatów audio. Droga, jaką obrano, pozwala na łatwe rozszerzanie obsługiwanych formatów. Ważne jest tylko, aby pojedynczy rdzeń \textit{Cortex M0+} poradził sobie z obsłużeniem dekodowania nowego formatu w czasie rzeczywistym.
	
%	\paragraph{Flagi przerwań}
%	Jak wcześniej wspomniano, przerwania generowane przez kanały DMA ustawiają dwie flagi \lstinline|a_done_irq| lub \lstinline|b_done_irq|. Poprzez wspólną pamięć są one odczytywane przez rdzeń 1, a ten dekoduje dane i uzupełn

	\paragraph{Część Decode}
	Komponenty z tej rodziny odpowiedzialne są za dostarczanie nowych danych surowych (w kodzie \lstinline|raw_buf|(\textit{raw buffer}) lub \lstinline|cbuf| (\textit{content buffer})). Klasa bazowa \lstinline|DecodeBase| odpowiada za wspólne elementy obu źródeł danych. Obsługuje ona m.in. zunifikowane funkcje do wysyłania komunikatów o zakończeniu dekodowania, zużyciu danych z bufora, bądź błędach. Umożliwione zostało także odczytywanie statystyk i metadanych. Poszczególne klasy podrzędne skupiają się na dostarczaniu danych z różnych źródeł. \lstinline|DecodeFile| odpowiada za odczyt plików z karty SD, natomiast \lstinline|DecodeStream| odbiera dane ze strumienia internetowego.
	
	\paragraph{Część Format}
	Powstały interfejs \lstinline|Format| służy do abstrakcji dekodowania danych surowych. Jego główną metodą jest \lstinline|decode_up_to_n|, która dekoduje co najwyżej \lstinline|n| jednostek danych. Aby dowiedzieć się ile jednostek należy zdekodować istnieją funkcje \lstinline|units_to_decode_whole| i \lstinline|units_to_decode_half|, zwracające odpowiednio ile jednostek zapełni cały bufor \lstinline|audio_pcm| a ile pół bufora (taka liczba jest dekodowana po otrzymaniu przerwania od DMA, którego jeden kanał transferuje pół bufora). W przypadku formatu WAV jednostki to po prostu bajty, a gdy mówimy o MP3 będą to ramki. Podklasy implementują specjalizowane funkcje do dekodowania poszczególnych formatów.
	
	\paragraph{Bufor FIFO}
	RP2040 posiada wbudowane dwa bufory FIFO do komunikacji między rdzeniami. Jeden z rdzenia 0 do rdzenia 1, drugi w przeciwnym kierunku. Wykorzystany został bufor w kierunku $1 \rightarrow 0$ do przekazywania informacji o stanie dekodowania. Zaimplementowany został moduł \lstinline|mcorefifo| do wysyłania abstrakcyjnych wiadomości. Wykorzystuje on przerwanie SIO do odbioru komunikatów, a następnie przekazuje je do zarejestrowanego odbiorcy. Jednym z takich odbiorców jest moduł odtwarzacza, który w pliku \lstinline|decodebase.cpp| odbiera komunikaty o identyfikatorze \lstinline|PLAYER| w funkcji \lstinline|player_msg()| i przekazuje do swojej głównej pętli w funkcji \lstinline|play()|.
	
	\subsubsection{Biblioteka \textit{helixmp3}}
	Do dekodowania formatu MP3 wykorzystana została biblioteka \lstinline|helixmp3|. Opiera się ona na arytmetyce stałoprzecinkowej. Oryginalnie napisana przez \textit{RealNetworks}\textsuperscript{\cite{realnetworks}} w 2003 roku, znaleziona została w internecie pod postacią repozytoria GitHub\textsuperscript{\cite{helixmp3_repo}}. Do tej biblioteki dodana została obsługa RP2040 jak również integracja ze środowiskiem CMake. Jest to pierwszy wynik w wyszukiwarce Google (fraza \textit{mp3 decoding library fixed point}), dlatego poczynione ulepszenia, zostały zgłoszone autorowi repozytorium\textsuperscript{\cite{helixmp3_pr}}. Umożliwiona została także statyczna alokacja buforów na dane dekodera.
	
	Do biblioteki dekodującej odwołuje się tylko \lstinline|FormatMP3|, który funkcją \lstinline|decode_up_to_n|, dekoduje co najwyżej \lstinline|n| ramek MP3. Zwracana jest liczba zdekodowanych ramek. Jeżeli zdekoduje ich mniej, to znaczy, że odtwarzanie zakończyło się pomyślnie (np. koniec pliku). Jeżeli zwrócona zostanie wartość mniejsza od zera, oznacza to błąd. Jeżeli danych w buforze brakuje (np. niestabilna komunikacja sieciowa), rdzeń 1 czeka na dane w nieskończoność. Użytkownik jednak w każdej chwili może przerwać oczekiwanie.
	
	\subsection{Rozpoczynanie odtwarzania}
	\imgcs{3/PicoRadio-start}{Schemat procesu rozpoczynania odtwarzania}{0.7}
	Użytkownik rozpoczyna odtwarzanie poprzez wybranie pozycji z listy ulubionych lub wyszukanie stacji/wybór pliku na karcie SD. Dowolny widok może zainicjować ekran odtwarzania \lstinline|ScPlay|. Jednym z parametrów inicjalizacyjnych jest ścieżka dostępu. Gdy nastąpi zmiana aktywnego ekranu, wywoływana jest funkcja \lstinline|player_start()|. Więcej na temat widoków i zarządzania ekranem napisano w sekcji \ref{?}. % TODO uzupełnić ref
	
	\paragraph{Zadania systemu FreeRTOS}
		Funkcja \lstinline|player_start()| tworzy dwa osobne zadania w systemie operacyjnym, a sama kończy działanie od razu. Pierwsze z nich, \lstinline|player|, odpowiedzialne jest za uruchomienie procesu odtwarzania i przetwarzanie komunikatów (np. odnośnie konsumpcji bajtów z bufora czy wystąpienia błędów). Ładuje ono także dane do bufora z pliku. Drugie, pomocnicze zadanie \lstinline|player stat| służy do okresowego aktualizowania stanu odtwarzania na ekranie.
	
	\paragraph{Wykrywanie formatu}
		Format audio wykrywany jest na podstawie ścieżki do zasobu. Jeżeli ta zaczyna się od \lstinline|http|, zostanie użyta klasa \lstinline|DecodeStream| i \lstinline|FormatMP3|. Jeżeli początek nie dopasuje się do wzorca, przyjmowane jest odtwarzanie z pliku (klasa \lstinline|DecodeFile|) i na podstawie rozszerzenia pliku definiowane jest użycie klasy \lstinline|FormatWAV| lub \lstinline|FormatMP3|.
		
	\paragraph{Ograniczenia detekcji plików}
		Definicja formatu audio przebiega na samym początku co jest poważnym ograniczeniem i nie pozwala na zmianę formatu np. po odczytaniu nagłówka \lstinline|Content-type|. Jednak w obecnej formie projekt obsługuje tylko strumieniowanie plików MP3. Gdyby została dodana obsługa stacji AAC/AAC+ należałoby poprawić ten fragment kodu. Dodatkowo wtedy detekcja formatu plików lokalnych mogłaby zostać przeniesiona do \lstinline|DecodeFile|. Oprócz rozszerzeń, możliwa byłaby detekcja formatów plików na podstawie ich nagłówków. Pliki rozpoczynające się od \lstinline|http| zostaną potraktowane jako strumienie audio. Należy rozważyć użycie prefiksu \lstinline|file://| dla plików lokalnych.
	
	\paragraph{Możliwe błędy}
		Jeden z możliwych błędów występuje, gdy nie zostanie dopasowany żaden znany format audio. Należy wtedy zweryfikować czy pliki posiadają odpowiednie rozszerzenia, a strumienie sieciowe prefiks \lstinline|http|. Inny błąd oznacza że nie udało się rozpocząć odtwarzania, tzn. plik nie istnieje/nie można go odczytać lub serwer strumieniujący nie odpowiada lub też nie udało się określić jego adresu. Przedstawione poniżej zakańczanie odtwarzania nie uwzględnia tych błędów, ponieważ z punktu widzenia programu jeszcze się ono nie rozpoczęło.
	
	\subsection{Zatrzymywanie odtwarzania}
	\imgcs{3/PicoRadio-stop}{Schemat obsługi żądań zakończenia odtwarzania}{1}
	Zakończenie przetwarzania audio jest nietrywialnym procesem. Sygnał do zatrzymania może pochodzić z trzech różnych źródeł. Na rysunku~\ref{3/PicoRadio-stop} przedstawione zostały kolejne etapy obsługi tych sygnałów. Natomiast poniżej opisano skrótowo jak działa zgłaszanie poszczególnych kategorii zdarzeń. 
	$ $\\
	
	Parametrem funkcji \lstinline|DecodeBase::notify_playback_end(bool error)| jest flaga, która mówi, czy odtwarzanie zakończyło się błędem. Jeżeli jest ona ustawiona, to program wyświetli ekran błędu.
	
	\paragraph{Użytkownik}
		Użytkownik może zakończyć odtwarzanie poprzez naciśnięcie przycisku \textit{Wstecz} na ekranie odtwarzania. Podsystem wyświetlacza wywołuje wtedy funkcje \lstinline|player_stop()|, która rozpoczyna proces zakończenia odtwarzania i czeka aż rzeczywiście się ono zakończy. Ustawiana jest flaga \lstinline|abort|, która powoduje, że wszystkie implementacje \lstinline|decode_up_to_n(int n)|, kończą dekodowanie natychmiast. Dekodowane jest mniej ramek niż zadane \lstinline|n|, co wykrywane jest przez program jako zakończenie odtwarzania.
	
	\paragraph{Koniec pliku}
		Gdy funkcja \lstinline|load_buffer()| w \lstinline|DecodeFile| napotka koniec pliku powiadamia o tym fakcie klasę nadrzędną wywołując \lstinline|notify_eof()|. Nie używa ona bezpośrednio funkcji \lstinline|notify_playback_end()|, ponieważ przy zakończeniu odtwarzania bufor może zawierać jeszcze do 4 sekund dźwięku (bufor 64kB, format MP3 128kbps). Dopiero gdy funkcja oczekiwania na dane wykryje że jest ich za mało, a w pliku nie ma więcej bajtów do odczytania, odtwarzanie jest zakańczane. Dzieje się to w analogiczny sposób jak w przypadku zakończenia go przez użytkownika: dekodowane jest mniej ramek audio.
	
	\paragraph{Błąd}
		Błędy modułu odtwarzacza mogą być dwojakie. Błąd sieciowy występuje przy odtwarzaniu strumieni internetowych, np. radia. Biblioteka \textit{LWIP} zgłasza błąd, który poprzez \lstinline|notify_playback_end()| powoduje natychmiastowe zatrzymanie odtwarzania i wyświetlenie komunikatu o błędzie (flaga \lstinline|error| ustawiona na \lstinline|true|). Błąd odczytu z pliku występuje, gdy funkcja uzupełniająca bufor o dane z pliku zakończy się niepowodzeniem. Oznaczać to może na przykład że użytkownik usunął kartę SD z urządzenia lub wystąpił błąd komunikacji z nią. Analogicznie jak w przypadku błędu sieci odtwarzanie jest zakańczane natychmiast.
		
	\subsection{Metadane}
	Jednym z wymagań projektu było wyświetlanie aktualnie odtwarzanego utworu. Należało więc co najmniej zdekodować metadane wysyłane przez stacje radiowe. Dodatkowo, zostało zaimplementowane odczytywanie metadanych z plików MP3.
	
	\subsubsection{Stacje radiowe -- ICY}
		Szeroko stosowanym formatem przesyłania danych o utworach w strumieniach radiowych jest format ICY\textsuperscript{\cite{icy_spec}}. Klient może zażądać od serwera metadanych wysyłając do niego nagłówek \lstinline|Icy-Metadata: 1|. Serwer, jeżeli zaakceptował żądanie, odsyła nagłówek \lstinline|icy-metaint: <n>|. Jego wartość oznacza co ile bajtów strumienia będą wysyłane ramki z metadanymi. Zwykle \lstinline|<n>| jest równe 16000, co oznacza, że co każde odebrane 16000 bajtów wystąpią metadane. Jest to 1 sekunda dźwięku MP3 128kbps, czyli nazwy utworów będą aktualizowane raz na sekundę. Występuje też wartość 1000, co oznacza 16 aktualizacji w ciągu sekundy. Inne wartości są możliwe, ale nie są spotykane w praktyce.
		
		\paragraph{Abstrakcyjne położenie ramek ICY}
		Warto zaznaczyć, że miejsce wstawienia metadanych w żaden sposób nie uwzględnia formatu audio. Nie możemy zakładać że nie podzielą one jednej ramki MP3 na dwie części. Dla dźwięku MP3 128kbps ramka ma rozmiar 418 bajtów. Przy wartości \lstinline|icy-metaint| równej 16000, dane dźwiękowe będą podzielone co ok. $38.28$ ramki. Z tego powodu konieczne stało się obsługiwanie ramek ICY w momencie zapisu do bufora, zamiast przy jego odczycie. Odczyt obsługuje odpowiednia instancja \lstinline|Format|, która nie musi obsługiwać odczytywania ramek bajt po bajcie. Na przykład \lstinline|FormatMP3| nie obsługuje dekodowania ramek w częściach. Ramka MP3 musi znaleźć się w ciągłym obszarze pamięci, nie może być rozdzielona ramką ICY.
		$ $\\
		
		Funkcja \lstinline|DecodeStream::play()|, jeżeli dostępny jest nagłówek \lstinline|icy-metaint|, inicjalizuje odbierane danych metodą \lstinline|ICY::start()|. Następnie rejestruje odwołanie, które jest wywoływane po każdym zapisie do bufora oraz przetwarza już odebrane dane. W trakcie tych czynności blokowany jest kontekst biblioteki sieciowej, aby w trakcie przetwarzania danych nie zostały odebrane żadne nowe dane, a po odblokowaniu każde następne były wychwycone przez funkcję \lstinline|cbuf_write_cb()|.
		
		W każdym z tych scenariuszy (wstępne i późniejsze przetwarzanie) wywoływana jest w pętli funkcja \lstinline|ICY::read()|. Pętla jest potrzebna, ponieważ w porcji odebranych danych, szczególnie dla niskich wartości \lstinline|icy-metaint|, może wystąpić więcej niż jedna ramka ICY.
		
		\imgcs{3/PicoRadio-icy}{Ramka MP3 rozdzielona ramką ICY}{0.9}
		\paragraph{Format danych ICY}
			Nagłówek metadanych ICY składa się z jednego bajtu kodującego rozmiar danych (bez nagłówka) podzielony przez 16. Dane dopełniane są zerami do podanego rozmiaru. Wewnątrz ramki kolejne pola oddzielone są od siebie średnikami, a same pola są w formacie \lstinline|klucz='wartosc'|. Dekoder zaimplementowany w projekcie obsługuje tylko klucz \lstinline|StreamTitle|, którego wartość to zazwyczaj tytuł utworu i jego wykonawca. Ramka ICY została przedstawiona na rysunku~\ref{3/PicoRadio-icy}.
			$ $\\
			
		Wywołanie \lstinline|ICY::read()| kopiuje ramkę ICY z bufora audio do bufora tymczasowego, a następnie przesuwa dane za ramką wstecz o rozmiar ramki. Operację można porównać do wycinania tekstu z dokumentu tekstowego. W ten sposób przywracamy ciągłość ramce MP3. Dane w buforze tymczasowym nie są interpretowane aby zaoszczędzić cenny czas. Przypomnijmy, cała ta operacja odbywa się przy zablokowanej komunikacji sieciowej. Dane interpretowane są dopiero gdy zadanie \lstinline|player stat| wywoła \lstinline|DecodeBase::get_meta_str()|, która w implementacji \lstinline|DecodeStream| odwołuje się do metody \lstinline|ICY::get_stream_title()|. Funkcja ta blokuje mutex bufora tymczasowego i kopiuje dane do swojego buforu na stosie. Dopiero wtedy rozpoczyna potencjalnie kosztowną czasowo interpretację danych.
	
	\subsubsection{Lokalne pliki MP3 -- ID3v2}
		Tagowanie MP3 obsługiwane jest zupełnie różnie od ramek ICY. Mogą one występować na początku plików MP3. Sygnalizuje to fakt, że pliki te rozpoczynają się 3 bajtami równymi \lstinline|ID3|. Funkcje do obsługi tego typu tagowań zostały zaimplementowane w klasach pochodnych \lstinline|Format|. Wykorzystana została już wcześniej istniejąca funkcja \lstinline|Format::decode_header()|. Obsługiwała ona dekodowanie nagłówków WAVE. Wywoływana jest ona po pierwszym załadowaniu bufora, tylko raz na dany plik/strumień. Implementacja \lstinline|FormatMP3| wywołuje wtedy funkcję \lstinline|ID3::try_parse()|.
		
		\paragraph{Standard ID3v2}
		Ramki ID3 w wersji drugiej mają znacznie bardziej rozbudowane kodowanie od np. ramek ICY czy starszego formatu ID3v1. Dokumentacja oryginalnie dostępna była pod adresem \href{id3.org}{id3.org} lecz w trakcie pisania pracy była ona niedostępna. Skorzystano z alternatywnej strony\textsuperscript{\cite{id3_spec_mutagen}}.
		
		\paragraph{Format ramek}
		\imgcs{3/PicoRadio-id3}{Format danych ID3v2}{0.8}
		Budowa formatu ID3v2 została przedstawiona na rysunku~\ref{3/PicoRadio-id3}. Podstawową jednostką budowy są tagi. Może być ich w pliku dowolna liczba. Są one opakowane dodatkowymi informacjami, takimi jak np. nagłówki. Z głównego nagłówka pobierany jest rozmiar i flaga czy nagłówek rozszerzony jest obecny. Jeżeli tak, to jest on ignorowany. Padding i stopka również są ignorowane.
		$ $\\
		
		Parser rozpoznaje ramki o kodach \lstinline|TPE1|(artysta) i \lstinline|TIT2|(tytuł). Są to ramki tekstowe, dlatego wyszczególniono taki format ramek na rysunku. Pierwszy bajt oznacza jakie kodowanie wykorzystano do zapisania tekstu. Możliwe formaty to ISO-8859-1, UTF-16, UTF-16BE i UTF-8. Wszystkie zostały zaimplementowane i przetestowane.
	
	\section{Bufor kołowy}
	\imgcs{3/PicoRadio-buffer}{Schemat wykorzystania bufora kołowego}{0.8}
	Małym, lecz kluczowym modułem w projekcie jest bufor kołowy \lstinline|CircularBuffer|. Używany jest on przede wszystkim przy odtwarzaniu dźwięku. Schematyczne wykorzystanie przedstawiono na rysunku~\ref{3/PicoRadio-buffer}. Poniżej zostały opisane najważniejsze jego funkcje.
	
	\paragraph{Zapis i odczyt danych przez różne wątki}
		Dzięki zastosowaniu osobnych liczników do zapisu i odczytu danych, nie występuje problem wyścigu. Każda operacja może być wykonywana niezależnie przez co najwyżej jeden wątek.
		
	\paragraph{Funkcje zgłaszające}
		Moduł umożliwia zarejestrowanie funkcji, które zostaną wywołane po odczytaniu lub zapisaniu danych. Wykorzystywane są np. do potwierdzenia odbioru w komunikacji sieciowej lub do wycięcia metadanych ICY.
	
	\paragraph{Sprawdzanie stanu zapełnienia i czekanie}
		Udostępniony jest szereg funkcji określających stan bufora. Można odczytać pozycje odczytu/zapisu bezpośrednio, lecz poza procesem tworzenia oprogramowania, nie jest to przydatna metryka, ponieważ bufor "zapętla się". Istotniejszą metryką jest natomiast to, ile danych zostało zapisane do bufora a ile odczytane od początku komunikacji. Dzięki tym danym możliwe jest jednoznaczne określenie, ile danych jest gotowych do odczytania w danej chwili, oraz ile jest to procent całkowitej pojemności bufora.
	
	\paragraph{Zapętlanie}
		Najważniejszą funkcją bufora jest jego zapętlanie. Problem pojawił się w chwili implementacji dekodera MP3, ponieważ rozmiar bufora nie dzielił się całkowicie przez długość ramki. To znaczy, ostatnia ramka w buforze była nieciągła. Pierwsza część mogła znaleźć się na końcu bufora, a druga na jego początku. Problem rozwiązano poprzez dołożenie przed początkiem kilku kilobajtów pamięci, do której kopiowane są nieciągłe dane. Wskaźnik odczytu staje się wtedy ujemny. Poszczególne sekcje bufora zostały również pokazane na rysunku~\ref{3/PicoRadio-buffer}. Część normalna \lstinline|buffer| rozpoczyna się zerowym wskaźnikiem odczytu \lstinline|read_at|. Część ukryta \lstinline|buffer_hidden| znajduje się bezpośrednio przed nią.
	
	\paragraph{Wycinanie zapisanych danych}
		Implementacja wycinania stała się konieczna w momencie kiedy w środku niepodzielnej jednostki przy odczycie (np. ramki MP3) pojawiają się metadane jak np. ICY. Trzeba je wtedy przetworzyć i usunąć, zapełniając powstałą lukę danymi występującymi dalej w buforze.
	
	\section{Klient protokołu HTTP}
		Potrzeba stworzenia własnej implementacji klienta HTTP stała się konieczna, aby zintegrować go z buforem kołowym i biblioteką sieciową. Obsługuje on przekierowania i podstawowe nagłówki. Wystarczająco, aby z powodzeniem pobierać wyniki wyszukiwań stacji oraz odtwarzać je. Implementacja jest dwuczęściowa. Nadrzędny moduł \lstinline|HttpClient| obsługuje wysokopoziomowy standard HTTP. Zajmuje się komponowaniem żądań, ich nagłówków, a także przetwarzaniem odpowiedzi. Podrzędny moduł obsługuje niskopoziomową komunikację sieciową. Taka budowa modułowa pozwoliła na testowanie serwera w środowisku PC ze stosowną implementacją modułu podrzędnego. Urządzenie zawiera moduł \lstinline|HttpClientPico|, który współpracuje z zasobami dostępnymi na mikrokontrolerze.
		$ $\\
		
		Obsługiwane nagłówki są ograniczone z uwagi na chęć statycznej alokacji pamięci. Żądanie wysyłane jest z nagłówkami:
		\begin{itemize}
			\item \lstinline|Host| o wartości hosta z którego pobierane są dane,
			\item \lstinline|User-agent: PicoRadio/0.1|,
			\item \lstinline|Icy-MetaData| o wartości \lstinline|1|, jeżeli program ustawił odpowiednią flagę.
		\end{itemize}
		Natomiast przetwarzane są następujące nagłówki odpowiedzi:
		\begin{itemize}
			\item \lstinline|Location| -- wykorzystywane przy przekierowaniach,
			\item \lstinline|Content-Type| -- typ treści, używane głownie przy przetwarzaniu wyników wyszukiwania,
			\item \lstinline|Content-Length| -- długość treści, j.w.
			\item \lstinline|Icy-Metaint| -- używane przy przetwarzaniu metadanych ICY.
		\end{itemize}
		
		Niestety brak jest obsługi szyfrowania. Środowisko zawiera implementację TLS, lecz nie została ona wykorzystana z uwagi na prawdopodobnie niewystarczającą moc obliczeniową mikrokontrolera. Wiele stacji transmituje z użyciem protokołu HTTP, tylko niewielka część z nich wymuszała przekierowania na szyfrowaną transmisję. Serwer musi je obsługiwać ponieważ wiele stacji wykorzystuje je do geolokalizacji serwera transmitującego. W konfiguracji zawarta została opcja \lstinline|HTTP_MAX_REDIRECTS| (domyślnie 2), która mówi, ile razy maksymalnie przekierowań chcemy obsłużyć. Zwykle jeżeli jest to więcej niż jedno, serwer próbuje wymusić transmisję szyfrowaną.
		
	\section{Dane}
		Główną jednostką informacji w projekcie jest stacja radiowa. Na potrzeby unifikacji dostępu do danych o stacjach powstał interfejs \lstinline|DataSource|. Zawiera on dwie metody:
		\begin{itemize}
			\item \lstinline|read_char()| -- odczytuje znak,
			\item \lstinline|more_content()| -- zwraca czy w źródle jest więcej danych.
		\end{itemize}
		Nad metodą czytającą znak po znaku zaimplementowana została metoda \lstinline|read_line()| czytająca linia po linii. Obsługuje ona zakończenia linii \lstinline|\n| oraz \lstinline|\r\n|. Wykorzystywana jest ona przez moduł list oraz, aby uniknąć duplikacji kodu, przez klienta HTTP do przetwarzania odpowiedzi.
		
		\subsection{Listy}
			Listy implementują wczytywanie różnych formatów. Przechowują także wskaźniki na bufory danych, które są wspólne dla każdej implementacji. Klasa \lstinline|List| jest klasą nadrzędną. Odczytuje ona źródło danych linia po linii, a następnie przekazuje do funkcji \lstinline|List::consume_line_format()| której implementacja zawarta jest w podklasach opisanych poniżej. Dokonuje ona właściwej interpretacji formatu.
			
			\paragraph{Statyczna alokacja} Wszystkie klasy list są tworzone statycznie i współdzielą pamięć wpisów. Jest to bardzo istotnie w środowisku o ograniczonej pamięci operacyjnej. Zazwyczaj ładowanie jednego typu wyników nie koliduje z pozostałymi, a jeżeli tak się dzieje to resetowany jest stan programu ładującego który przy następnym użyciu musi przeładować dane listy, bo zostały one nadpisane. Z tego też powodu modyfikowanie listy ulubionych odbywa się bezpośrednio w pamięci stałej, bez ładowania całej listy stacji. Statyczna alokacja ma też swoje pozytywne strony, mianowicie przechowywany jest stan list. Po powrocie z wybranej stacji do wyników ładowania (do listy ulubionych lub wyszukiwania) nie ma potrzeby od nowa ładować danych.
			
			\subsubsection{Format M3U}
				Jednym z formatów obsługiwanych przez projekt jest format M3U\textsuperscript{\cite{m3u}} w wersji \textit{Extended}. Format ten został wybrany z uwagi na jego prostotę budowy oraz to, że strony agregujące stacje radiowe go obsługują. Jest to popularny format zapisu list odtwarzania. W wersji standardowej przybiera postać linków do plików/strumieni zapisanych w osobnych liniach pliku tekstowego. Wersja rozszerzona wprowadza specjalne komentarze. Zaimplementowany interpreter obsługuje komentarz \lstinline|EXTINF|, który zawiera czas trwania ścieżki oraz jej nazwę.
			
			\subsubsection{Format PLS}
				Niektóre stacje radiowe przed wysłaniem strumienia audio, wysyłają plik w formacie PLS\textsuperscript{\cite{pls}}. Plik taki zawiera różne warianty tego samego strumienia w celu równoważenia obciążenia. Po wykryciu tego formatu ładowane są pierwsze 2 stacje (konfigurowalne) i wybierana jest losowa z nich. Format składa się z par deklaracji postaci \lstinline|FileX| i \lstinline|TitleX|, gdzie \lstinline|X| to kolejne liczby naturalne.
			
		% TODO \subsection{Wpis na liście}
		% TODO \subsection{Pliki pomocnicze}
			
		\subsection{Klasy ładujące}
			Wczytywanie list z konkretnych źródeł danych implementowane jest przez podklasy klasy \lstinline|Loader|. Prezentuje ona spójny interfejs do ładowania danych. Metody \lstinline|load()| oraz \lstinline|load_abort()| umożliwiają zarządzanie tym procesem. Tworzone jest zadanie systemowe, które wykonuje potrzebne kroki bez blokowania interfejsu użytkownika. Funkcje \lstinline|get_entry_count()| oraz \lstinline|get_entry()| pozwalają na pobieranie informacji o wynikach. Klasa obsługuje także paginację wyników. Podklasy mogą definiować własne funkcje \lstinline|begin()|, które pełnią rolę konstruktora obiektu (przekazują niezbędne parametry, ale bez dynamicznej alokacji pamięci). Mogą one wymagać podania ścieżki lub np. słowa kluczowego do wyszukania.
			
			\subsubsection{Wyniki wyszukiwania}
				Pierwszą implementacją klasy ładującej była klasa służąca do wczytania wyników wyszukiwania stacji \lstinline|LoaderSearch|. Poprzez metodę \lstinline|begin(query)| przekazywana jest jej fraza do wyszukania. Następnie następuje odwołanie do klienta HTTP, który implementuje interfejs \lstinline|DataSource|. Agregat stacji radiowych zwraca dane wraz z nagłówkiem \lstinline|Content-Type|. Jego wartość determinuje, która lista zostanie użyta do interpretacji. Typ \lstinline|audio/mpegurl| oznacza \lstinline|ListM3U|, natomiast \lstinline|audio/scpls| lub \lstinline|audio/x-scpls| implikuje wykorzystanie \lstinline|ListPLS|. Tak załadowana lista stacji jest dostępna dla reszty systemu poprzez metody klasy nadrzędnej \lstinline|Loader|.
			
			\subsubsection{Ulubione stacji}
				Z uwagi na gotową implementację formatu M3U, zdecydowano się na wykorzystane go do przechowywania listy ulubionych stacji. Prostota formy oznaczała że możliwe będzie dodawanie wpisów w miejscu bez konieczności ładowania całego pliku do pamięci. Kolejną zaletą jest fakt, że pliki \lstinline|.m3u| to pliki tekstowe. Przewidziano możliwość zaimplementowania funkcji eksportowania i importowania listy ulubionych na kartę SD. Użytkownik mógłby modyfikować plik we własnym zakresie dodając stacje niebędące w ogólnodostępnym spisie stacji. Na ten moment nie zostało to zaimplementowane.

			\subsubsection{Znane sieci Wi-Fi}
				Tutaj także zostały wykorzystane pliki w formacie M3U. Nazwa sieci przechowywana jest jako nazwa stacji, a pole \lstinline|url| wykorzystano na przechowywanie hasła. Lista ta, razem z listą ulubionych stacji używa klasy bazowej \lstinline|LoaderM3U|. Dzięki temu implementacja interpretacji formatu jest jedna. Wczytywanie listy następuje w ekranie ustawień, jak i po uruchomieniu urządzenia, w celu automatycznego połączenia z najlepszą siecią.
				
			\subsubsection{Wykryte sieci Wi-Fi}
				Do skanowania pobliskich sieci została stworzona implementacja \lstinline|LoaderWifiScan|. Uruchamia ona skanowanie sieci przy pomocy wbudowanego w środowisko \lstinline|pico-sdk| sterownika układu Wi-Fi. Zwracane sieci są w losowej kolejności, często zduplikowane. Aby temu zaradzić, jak i obsłużyć stronicowane wyników, stworzona została klasa \lstinline|LFSorter|, opisana poniżej.
				
			\subsubsection{Pliki lokalne}
				Interfejs list i klas ładujących okazał się także przydatny przy ładowaniu listy lokalnych plików z karty SD. Klasa \lstinline|LoaderLocal| wykorzystuje referencję do klasy \lstinline|Path|, która implementuje również metody poruszania się po strukturze folderów. Metoda \lstinline|go()| powoduje zejście w dół struktury drzewiastej, natomiast \lstinline|up()| umożliwia przejście poziom wyżej. Metody obsługi systemu plików zwracają listingi katalogów w kolejności dodawania plików do niego. Porządek alfabetyczny, jak i priorytet folderów został osiągnięty przy wykorzystaniu klasy \lstinline|LFSorter|.
				
			\subsubsection{Stałe wyniki}
				Bardzo prosta klasa ładująca, przepisuje ona jedynie wyniki z pamięci stałej do listy wyników. Używana przez ekran ustawień.
				
%		\paragraph{Karta SD -- FatFS}
		\subsection{Pamięć Flash -- LittleFS}
			Aby lista ulubionych stacji czy lista zapisanych sieci Wi-Fi były przechowywane pomiędzy wyłączeniami urządzenia, musiały one być zapisane w pamięci nieulotnej. Mikrokontroler RP2040 przechowuje program w zewnętrznej pamięci typu \textit{flash}. Na płytkach Pi Pico dostarczone zostały układy o rozmiarach 2MB. Środowisko programistyczne umożliwia, oprócz oczywistej operacji odczytu, także zapis do tej pamięci. Wykorzystano tą właściwość do umieszczenia w końcowych 64KB systemu plików LittleFS\textsuperscript{\cite{littlefs}}, specjalnie stworzonego do przechowywania danych w środowiskach wbudowanych i pamięciach typu \textit{flash}. Stworzona została klasa \lstinline|LFSAccess|, która dostarcza podstawowe metody do manipulacji tekstami, jak również implementuje interfejs \lstinline|DataSource|.
			
		\subsection{Sortowanie -- LFSorter}
			Niektóre metody zwracają wyniki w postaci strumienia kolejnych wyników, bez możliwości indeksacji indywidualnych pozycji. Z powodu ograniczonej pamięci RAM, nie jest możliwe wczytanie wszystkich wyników i wybranie z nich kilku w zadanej kolejności. Ten problem rozwiązuje klasa \lstinline|LFSorter|, która zapisuje cały strumień do pamięci stałej \textit{flash} (przy użyciu \lstinline|LFSAccess|). Następnie, przy użyciu metody \lstinline|get_smallest_n_skip_k(n, k)|, pozwala wczytać elementy $k,\; k+1,\; ...,\; k+n-1$ z ciągu posortowanych elementów (indeksowanie od 0, sortowanie wg dostarczonej funkcji porównującej). Ciąg ten nie jest nigdzie zapisywany.
			
			\paragraph{Pamięć podręczna}
			Plik tymczasowy utworzony podczas procesu ładowania strumienia, może zostać wykorzystany w kolejnych wywołaniach. Np. z każdą nową stroną nie ma potrzeby skanować od nowa dostępnych sieci Wi-Fi czy ładować listingu lokalnego katalogu.
						
			\paragraph{Złożoność obliczeniowa}
			Wewnętrznie implementowany jest algorytm sortowania przez wybieranie, który ignoruje pierwsze $k$ elementów, a następnie zwraca kolejne $n$ elementów. Np. przy ładowaniu pierwszej strony wyników $k$ będzie równe 0. Liczba $n$ jest stała i równa maksymalnej liczbie elementów na jednej stronie. Jeżeli założymy, że liczba elementów w całym strumieniu będzie rzędu $k+n$ (np. ładujemy ostatnią stronę) to złożoność obliczeniowa algorytmu to $O((k+n)^2)$. Nie jest to efektywny algorytm, jednak pozwala maksymalnie zaoszczędzić pamięć RAM, gdyż jej użycie nie zależy od liczby wszystkich elementów.
			

		\subsection{Współpraca klas ze sobą}
			\imgh{3/PicoRadio-loaders}{Współpraca list z klasami ładującymi i ekranami}{0.95}
			Na rysunku~\ref{3/PicoRadio-loaders} przedstawiono współpracę poszczególnych klas. Klasy ładujące mogą wykorzystywać listy. Jeżeli to robią, ich źródło danych musi implementować interfejs \lstinline|DataSource|. Tak się dzieje w przypadku klas \lstinline|LoaderM3U| oraz \lstinline|LoaderSearch|. Ładują one dane odpowiednio z pamięci stałej oraz z Internetu. Interpretacja zachodzi przy użyciu odpowiednich list. Odmienna sytuacja ma miejsce w przypadku pozostałych klas. Nie interpretują one plików/strumieni, więc nie potrzebują być implementacjami \lstinline|DataSource|, ani używać list. Interfejsy do skanowania Wi-Fi i ładowania plików lokalnych zwracają nazwy kolejnych elementów bezpośrednio, bez konieczności interpretacji. Jednak są one losowe i wymagają posortowania przy wykorzystaniu \lstinline|LFSSorter|. Klasa \lstinline|LoaderConst| bezpośrednio przepisuje wyniki i jest najprostszą ze wszystkich. Służy do definiowania list o stałej zawartości.
			
			\paragraph{Ekrany}
				Istnieje powiązanie pomiędzy klasami ładującymi a ekranami. Każdej klasie ładującej przyporządkowany jest ekran, który wyświetla dane pozycje. Zawiera on w sobie referencję klasy ładującej. Przekazuje ją swojej klasie nadrzędnej jako wskaźnik do klasy ogólnej \lstinline|Loader|. Tym sposobem, każdy z ekranów może ustalać szczegółowe parametry ładowania, a ekran nadrzędny implementuje ogólne funkcje związane z wyświetlaniem załadowanych pozycji na ekranie.
	
	\section{Ekran}
		Z uwagi na założenie miniaturyzacji urządzenia wybrany został relatywnie mały ekran. Urządzenie firmy Adafruit zawiera wyświetlacz ciekłokrystaliczny (\textit{LCD}) o przekątnej 1.8 cala oraz sterownik ST7735S obsługiwany poprzez protokół SPI. Na ekranie znajdowała się folia z zieloną zakładką. Jest to istotne ponieważ na rynku występują także wersje oznaczone kolorem czerwonym, posiadające inne opcje programowania.
		$ $\\
		
		\noindent
		Moduł wyświetlacza został podzielony na następujące podmoduły:
		\begin{itemize}
			\item \lstinline|tft| -- niskopoziomowa obsługa komunikacji i rysowania,
			\item \lstinline|assets| -- zasoby do wyświetlania ikon i czcionek,
			\item \lstinline|screens| -- ekrany użytkownika
			\begin{itemize}
				\item \lstinline|wifi| -- ekrany Wi-Fi
			\end{itemize}
			\item \lstinline|screenvirt| -- ekrany wirtualne.
		\end{itemize}
		
		\subsection{Komunikacja niskopoziomowa}
			Kod niskopoziomowej komunikacji ze sterownikiem ekranu zawiera folder \lstinline|display/tft|. Inicjalizacja zapożyczona została z biblioteki firmy Adafruit. W pliku \lstinline|st7735_init.h| znajdują się definicje komend oraz listy poleceń potrzebne do uruchomienia wyświetlacza. Klasa \lstinline|ST7735S| zawiera metody \lstinline|reset()|, \lstinline|write_command_list()| oraz \lstinline|module_init()|, które odpowiadają za ustawienie poprawnych parametrów pracy urządzenia. Wszystkie wymagane operacje, włącznie z konfiguracją pinów mikrokontrolera, zawiera metoda \lstinline|ST7735S::init()|.
			
		\paragraph{Kolory}
			Do każdej funkcji przekazywany jest kolor w formacie 24 bitowego RGB, tj. po 8 bitów na kolor, w postaci jednej liczby. Kolor ten jest automatycznie mapowany na wewnętrzną 16 bitową reprezentację obsługiwaną przez sterownik. Podział na składowe RGB w tej postaci to:
			\begin{itemize}
				\item 5 bitów -- kolor czerwony (najstarsze),
				\item 6 bitów -- kolor zielony,
				\item 5 bitów -- kolor niebieski.
			\end{itemize}
		
		\imgh{3/PicoRadio-screen-xy}{Układ współrzędnych na ekranie}{0.45}
		\paragraph{Współrzędne}
			Na rysunku~\ref{3/PicoRadio-screen-xy} przedstawiono sposób, w jaki na ekranie reprezentowane są współrzędne. Na magistralę szeregową dane wysyłane są linia po linii.
		
		\subsection{Rysowanie}
			Aby przesłać kolory dla wybranych pikseli na ekranie, należy ustawić odpowiednie zmienne wskaźnikowe wewnątrz sterownika wyświetlacza. Funkcja \lstinline|ST7735S::setup_write()| pozwala na ich ustawienie i przekazanie początkowych oraz końcowych wartości współrzędnych. Dzięki temu na ekranie tworzony jest prostokąt dla którego należy przesłać zaktualizowane wartości pikseli w formacie podanym powyżej. Jednak oprócz funkcji do obsługi niskopoziomowej komunikacji klasa \lstinline|ST7735S|  wspiera także rysowanie prostokątów, czcionek i ikon.
			
			\subsubsection{Prostokąty}
				\imgh{3/PicoRadio-screen-rect}{Współrzędne prostokąta na ekranie}{0.6}
				Prostokąty rysowane są poprzez funkcję \lstinline|fill_rect(x, y, w, h, bg)|, gdzie:
				\begin{itemize}
					\item \lstinline|x| -- współrzędna kolumny ,
					\item \lstinline|y| -- współrzędna wiersza,
					\item \lstinline|w| -- szerokość,
					\item \lstinline|h| -- wysokość,
					\item \lstinline|bg| -- kolor tła (24 bitowe RGB).
				\end{itemize}
			
			\subsubsection{Czcionki}
				Każda czcionka składa się z dwóch tablic \lstinline|ascii_data_H| i \lstinline|utf8_data_H|, gdzie \lstinline|H| to rozmiar czcionki, tj. wysokość w pikselach (szerokość jest połową wysokości). Zostały one opisane strukturą \lstinline|font| w pliku \lstinline|assets/font.hpp|.
				
				\paragraph{Mapowanie}
					Pierwsza tablica zawiera znaki od spacji (kod \lstinline|0x20| ASCII) do tyldy (kod \lstinline|0x7E|). Druga z tablic zapewnia wyświetlanie znaków Unicode. Mapowanie jest tu arbitralne zapewnione funkcją sprawdzającą wartości 2-3 kolejnych bajtów danych. Zawiera ona obecnie 18 polskich znaków (wariant duży i mały) jak również symbol nieskończoności. Istnieje możliwość dodawania dowolnej liczby nowych znaków.
				
				\imgh{3/PicoRadio-screen-font}{Kodowanie czcionek (wartości 0x00 zastąpiono pustymi znakami)}{0.6}
				\paragraph{Kodowanie}
					Czcionki kodowane są jako bitmapy. Każda z tablic zawiera tyle elementów, ile jest pikseli we wszystkich znakach czcionki w tej tablicy. Każda wartość to jasność piksela (255 -- kolor pierwszoplanowy, 0 -- kolor tła). Dla przykładu czcionka podstawowa ASCII zawierająca 95 znaków o wymiarach 24x12 pikseli będzie miała rozmiar 27360 bajtów. Dodając 19 znaków Unicode otrzymujemy 32832 bajtów. Kodowanie znaku \lstinline|A| z tej czcionki przedstawia rysunek~\ref{3/PicoRadio-screen-font}.
				
				$ $\\
				W projekcie została wykorzystana czcionka Ubuntu\textsuperscript{\cite{ubuntu_font}} w wersji Mono (stała szerokość każdego znaku). Stworzony skrypt w języku Python wygenerował potrzebne bitmapy do projektu. Dostępne rozmiary czcionki to 12 (rozmiar ok. 8kB), 16 (ok. 14kB) i 24 (ok. 32kB). Razem stanowi to 54kB, czyli 2.65\% pamięci ROM. Czcionka została zapisana w pliku \lstinline|assets/ubuntu_mono.cpp| a także utworzono funkcję dostępową \lstinline|ubuntu_font_get_size()|. 
				
			\subsubsection{Ikony}
				Ikony kodowane są w podobny sposób do czcionek. Różnią się tym, że każda ikona może mieć inny rozmiar i jest kodowana swoją własną tablicą. W projekcie znalazły się m.in. ikony:
				\begin{itemize}
					\item \lstinline|icon_backspace| -- 15x15, ikona usuwania tekstu,
					\item \lstinline|icon_back| -- 11x11, ikona wstecz,
					\item \lstinline|icon_fav_back| -- 15x16, ikona powrotu do listy ulubionych.
				\end{itemize}
		
		\subsection{Ekrany}
			\imgh{3/PicoRadio-screens}{Hierarchia ekranów}{0.55}
			Na rysunku \ref{3/PicoRadio-screens} przedstawiono hierarchię ekranów. Klasą nadrzędną wszystkich ekranów jest klasa \lstinline|Screen|. Implementuje ona podstawową siatkę przycisków, przechodzenie pomiędzy nimi, jak również rysowanie i aktualizację ruchomych tekstów. Bezpośrednimi potomkami tej klasy są ekrany o niestandardowym układzie (np. ekran odtwarzania). Jednak większość ekranów jest podklasami dwóch innych potomnych klas: \lstinline|ScreenList| i \lstinline|ScreenKb|. Są to klasy wirtualne (znajdują się w katalogu \lstinline|screenvirt|), niemogące istnieć bezpośrednio. Standaryzują one układ potomnych ekranów. Pierwsza z nich implementuje widok listy, a druga, widok klawiatury. \lstinline|ScreenKb| implementowana jest przez ekran wyszukiwania stacji i ekran wprowadzania hasła Wi-Fi.
			
		\subsection{Menedżer ekranów}
			Ekranami użytkownika zarządza plik \lstinline|screenmng.cpp|. Tworzy on szereg konstrukcji wymaganych do poprawnego obsłużenia interfejsu użytkownika. Poniżej zostały opisane wybrane z nich.
			
			\paragraph{Semafory}
				Aby zabezpieczyć dostęp do medium szeregowego, utworzony został semafor binarny \lstinline|mutex_display|. Zapewnia on ciągłość operacji przesyłu danych. Musi ona wystąpić ponieważ w sterowniku został wybrany prostokąt, którego kolory będą aktualizowane. Dodatkowo powstał \lstinline|mutex_ticker|, który zabezpiecza funkcję aktualizacji ekranów. Zadanie \lstinline|scr tick| jest wywoływane co 50ms i aktualizuje np. położenie ruchomych tekstów na ekranie.
				
			\paragraph{Instancje klas}
				W pliku zdefiniowano także instancje najważniejszych klas. Zdefiniowana jest instancja klasy \lstinline|ST7735S| oraz klas ładujących \lstinline|LoaderSearch|, \lstinline|LoaderFav| i \lstinline|LoaderLocal|. Statyczna definicja pozwala na analizę zużycia pamięci w trakcie kompilacji programu oraz chroni przed niedeterministyczną operacją rezerwowania pamięci w czasie działania programu.
				
			\paragraph{Obsługa ekranów użytkownika}
				Poszczególne ekrany użytkowników także zostały tutaj zainstancjonowane. Plik nagłówkowy \lstinline|screenmng.hpp| eksportuje te definicje, aby ekrany mogły ustawiać parametry innych ekranów, które otwierają. Znalazły się tutaj także funkcje do zmiany aktualnie wyświetlanego ekranu. Domyślnie zmiana ta odbywa się poprzez funkcję \lstinline|screenmng_input()|, do której przekazywane są naciśnięcia przycisków. Klasa bazowa wszystkich ekranów zawiera metodę \lstinline|Screen::input()|, która może zwrócić wskaźnik do ekranu, który ma zostać otworzony jako następny. Jest ona wywoływana przez funkcję zarządcy i jeżeli zwróci niezerowy wskaźnik to otwierany jest nowy ekran. Jednak w trakcie rozwoju oprogramowania, konieczne stało się zdefiniowanie funkcji \lstinline|screenmng_open()|, która może arbitralnie zmieniać otwarty ekran. Jest to używane np. przy zakończeniu odtwarzania. Wskaźnik \lstinline|current_screen| ustawiany jest zawsze na aktualnie otwarty ekran. Jest to użyteczne przy funkcji aktualizacji ekranu.

	\section{Wejście}
		\noindent
		Zawartość modułu znajduje się w 3 katalogach:
		\begin{itemize}
			\item \lstinline|buttons| -- Przyciski, interakcja z użytkownikiem,
			\item \lstinline|sd| -- Wykrywanie karty SD,
			\item \lstinline|analog| -- Odczyt poziomu naładowania baterii.
		\end{itemize}
		
		Katalogi te zawierają po 2 pliki (nagłówkowy i kod źródłowy) realizujące funkcje opisane poniżej.
		
		\subsection{Interakcje użytkownika}
			Dane od użytkownika pobierane są za pomocą przycisków. Każdy z nich dołączony jest bezpośrednio do mikrokontrolera. Naciśnięcie lub zwolnienie przycisku powoduje wywołanie zbocza opadającego lub, odpowiednio, rosnącego. Wykryte przez układ, aktywują one przerwanie. Eliminacja drgań styków została osiągnięta poprzez zastosowanie zewnętrznych kondensatorów i wbudowanych przerzutników Schmitta dostępnych na każdym wejściu RP2040. Przerwanie, zgodnie z dobrymi praktykami, ustawia jedynie odpowiednie flagi, które zostały opisane poniżej.
			
			\paragraph{Przekazywanie danych}
				Podsystem przycisków opiera się o dwie tablice zawierające odpowiednie dane dla każdego przycisku z osobna. Pierwsza z nich, o nazwie \lstinline|b_pressed[]|, zawiera wartości logiczne. Mówią one o tym czy przycisk jest w danej chwili wciśnięty czy nie. Druga, \lstinline|b_pressed_time_us[]|, zawiera informację, w której mikrosekundzie nastąpiło wciśnięcie przycisku. Używa ona wbudowanej funkcji \lstinline|time_us_32()| do pobierania czasu.
			
			\imgh{3/PicoRadio-buttons}{Maszyna stanów w module przycisków}{0.8}
			
			Przerwanie, oprócz ustawienia odpowiednich wartości w tablicach, wybudza zadanie \lstinline|input handle|. Zawiera ono maszynę stanów, która umożliwia, oprócz podstawowego przekazywania zdarzeń do interfejsu, powtarzanie naciśnięć, tak jak robią to klawiatury komputerowe. Dodatkowo zawarto w niej także obsługę wygaszania ekranu. Na rysunku~\ref{3/PicoRadio-buttons} przedstawiono jej funkcjonowanie.
			
			\paragraph{Zmienna \lstinline|timeout|}
				Czas oczekiwania na ponowne uruchomienie maszyny jest tym mniejszy im częściej dane zdarzenie może wystąpić. To znaczy, gdy żaden z przycisków nie jest naciśnięty, a ekran wygaszony, maszyna oczekuje w nieskończoność na sygnał z przerwania. Gdy ekran nie jest wygaszony, zadanie czeka co najwyżej 30~s. Po tym czasie następuje sprawdzenie warunków do wygaszenia, np. czy odtwarzanie jest uruchomione (pominięte na rysunku). Gdy są one spełnione, ekran zostaje wygaszony. Rozpoczęcie powtarzania następuje po 500~ms ciągłego naciskania. Kiedy użytkownik kliknął i przytrzymuje przycisk, zadanie czeka maksymalnie 500~ms, ponieważ po takim czasie nastąpi akcja wymagająca obsłużenia (wygenerowanie powtórzonego kliknięcia). Gdy przycisk dalej jest trzymany opóźnienie spada do 1/26~sekundy, ponieważ, gdy powtarzane jest naciśnięcie któregokolwiek przycisku, należy skrócić cykl wywoływania maszyny aby osiągnąć zadaną liczbę 26~powtórzeń na sekundę. Wszystkie czasy są konfigurowalne w momencie kompilacji programu.
		
		\subsection{Karta SD}
			Pin \textit{Card Detect} slotu na karty SD również został bezpośrednio podłączony do mikrokontrolera i działa zgodnie z tymi samymi zasadami co piny przycisków. Jednak obsługa wykrywania karty jest znacznie prostsza. Zadanie \lstinline|sd| wykrywa zmianę stanu na odpowiednim pinie i montuje lub odmontowuje kartę SD z wykorzystaniem biblioteki FatFS.
			
		\subsection{Bateria}
			Poziom baterii jest wykrywany poprzez użycie jednego z analogowych wejść procesora. Na wejściu zastosowano dzielnik napięcia, współczynnik podziału wynosi 2. Dzięki niemu maksymalne napięcie ogniwa 4.2V równa się 2.1V, co mieści się w zakresie pomiarowym mikrokontrolera (0V - 3.3V). W pliku \lstinline|analog.cpp| zaimplementowano funkcję \lstinline|battery_voltage()|, która zwraca napięcie ogniwa po wszystkich niezbędnych przekształceniach. Dodatkowo, kod zawiera aproksymację poziomu baterii w procentach. Funkcja \lstinline|battery_percentage()| zwraca liczbę z zakresu 0 - 100, która oznacza poziom naładowania ogniwa. Na podstawie wyniku tej funkcji rysowana jest ikona baterii w górnym pasku ikon statusowych. Ma ona kolor zielony i jest w pełni naładowana gdy bateria posiada 60\% lub więcej energii, 20\% i więcej to kolor żółty, natomiast poniżej 20\% ma ona kolor czerwony.
		
	\section{Wi-Fi}
		Obsługa sieci bezprzewodowej podzielona została na 3 pod-moduły:
		\begin{itemize}
			\item \lstinline|wificonnect| -- połączenie z Wi-Fi
			\item \lstinline|wifiscan| -- skanowanie dostępnych sieci
			\item \lstinline|wifibest| -- znalezienie najlepszej sieci do połączenia po uruchomieniu
		\end{itemize}
		
		Każdy z tych modułów dodaje nowe funkcje do przestrzeni nazw \lstinline|wifi|.
		
		\subsection{Połączenie z siecią Wi-Fi}
			Głównym zadaniem tej części modułu sieciowego jest pierwsze połączenie z siecią Wi-Fi po jej manualnym wyszukaniu i podaniu hasła. Służy do tego funkcja \lstinline|connect_async()|. Tworzy ona zadanie systemu operacyjnego \lstinline|wifi conn|, które próbuje połączyć się z daną siecią. Postęp procesu jest aktualizowany na ekranie przy pomocy wskaźników do funkcji przekazanych w strukturze \lstinline|cb_fns|. Są to:
			\begin{itemize}
				\item \lstinline|upd| -- ogólna aktualizacja, zawiera opis wykonywanego aktualnie kroku,
				\item \lstinline|scan| -- aktualizacja po znalezieniu sieci o podanej nazwie, zawiera siłę sygnału,
				\item \lstinline|conn| -- wywoływane po pomyślnym podłączeniu do sieci.
			\end{itemize}
			
			Odwołanie \lstinline|conn| powoduje także zapisanie sieci z hasłem do przyszłego użycia. Dodatkowe funkcje w tym module umożliwiają inicjalizację podsystemu Wi-Fi oraz np. sprawdzenie stanu połączenia.
			
		\subsection{Skanowanie dostępnych sieci}
			Wykorzystywany przez ekran \lstinline|ScWifiScan| oraz klasę ładującą \lstinline|LoaderWifiScan|, moduł ten umożliwia przeskanowanie pobliskich sieci metodą \lstinline|scan()|. Sieci te zapisywane są do pamięci stałej przy użyciu przekazanej instancji \lstinline|LFSAccess|. Następnie ładowanie kolejnych stron wyników umożliwia funkcja \lstinline|read(n, k)|, która działa analogicznie do funkcji \lstinline|LFSorter::get_smallest_n_skip_k(n, k)|. Sortowanie odbywa się nierosnąco wg siły sygnału.
			
		\subsection{Połączenie po uruchomieniu}
			Gdy urządzenie zostanie uruchomione, użytkownik oczekuje że samo odnajdzie ono najlepszą do połączenia sieć. Zachowanie takie implementuje funkcja \lstinline|connect_best_saved()|. Wykorzystuje ona funkcje \lstinline|scan()| i \lstinline|read()| żeby pojedynczo wczytywać sieci, poczynając od tej o najwyższej sile sygnału. Gdy sieć istnieje w zapisanych sieciach, inicjowane jest połączenie. W przeciwnym wypadku ładowana jest następna sieć i tak aż do skutku, albo do wyczerpania się przeskanowanych sieci.
		
	\pagebreak
	\begin{thebibliography}{9}
		\bibitem{radio-browser}
		\href{https://www.radio-browser.info/}{\textit{Radio-browser} -- baza danych stacji radiowych}
		\bibitem{fmstream}
		\href{http://fmstream.org}{\textit{fmstream} -- baza danych stacji radiowych}
		
		\bibitem{minimp3}
		\href{https://github.com/lieff/minimp3}{\textit{minimp3} -- biblioteka dekodująca MP3}
		\bibitem{realnetworks}
		\href{https://realnetworks.com}{\textit{RealNetworks} -- firma odpowiedzialna za bibliotekę \textit{helixmp3}}
		\bibitem{helixmp3_repo}
		\href{https://github.com/ultraembedded/libhelix-mp3}{\textit{helixmp3} -- biblioteka dekodująca MP3 (napisana w 2003 roku przez RealNetworks)}
		
		\bibitem{rp2040}
		\href{https://www.raspberrypi.com/documentation/microcontrollers/rp2040.html}{\textit{RP2040} -- Mikrokontroler firmy Raspberry Pi}
		\bibitem{pico_sdk}
		\href{https://github.com/raspberrypi/pico-sdk}{\textit{pico-sdk} -- Zestaw bibliotek do Raspberry Pi Pico}
		\bibitem{freertos_kernel}
		\href{https://github.com/FreeRTOS/FreeRTOS-Kernel}{\textit{FreeRTOS Kernel} -- Jądro systemu czasu rzeczywistego FreeRTOS}
		\bibitem{adafruit_st7735}
		\href{https://github.com/adafruit/Adafruit-ST7735-Library}{\textit{Adafruit-ST7735-Library} -- biblioteka do obsługi ekranów LCD napisana przez firmę Adafruit}
		\bibitem{littlefs}
		\href{https://github.com/littlefs-project/littlefs}{\textit{LittleFS} -- System plików przeznaczony do pamięci flash}
		\bibitem{fatfs}
		\href{http://elm-chan.org/fsw/ff/00index_e.html}{\textit{FatFS} -- Obsługa systemów plików z rodziny FAT}
		\bibitem{sdfs}
		\href{https://github.com/carlk3/no-OS-FatFS-SD-SPI-RPi-Pico}{\textit{FatFS+SPI na Pi Pico} --  kompleksowa biblioteka łącząca FatFS i komunikację poprzez SPI z kartą SD (przystosowana do Pi Pico)}
		
		\bibitem{radio_adapter}
		\href{https://allegro.pl/oferta/adapter-radia-internetowego-dual-ir-3a-dab-fm-rds-12692108793}{\textit{Radio sieciowe} -- Sklep Allegro}
		\bibitem{radio_tanie}
		\href{https://www.x-kom.pl/p/653480-radio-internetowe-technisat-sternradio-ir-2-biale.html}{\textit{Radio internetowe mono} -- Sklep x-kom}
		\bibitem{radio_drogie}
		\href{https://www.x-kom.pl/p/724674-radio-internetowe-blaupunkt-ir10bt.html}{\textit{Radio internetowe stereo} -- Sklep x-kom}
		\bibitem{botland_stm}
		\href{https://botland.com.pl/stm32-discovery/4715-stm32f746g-disco-discovery-stm32f746ng-cortex-m7-ekran-dotykowy-pojemnosciowy-43--5904422374082.html}{\textit{STM32F746G-Disco} -- Sklep Botland}
		
		\bibitem{radio_pico1}
		\href{https://github.com/episource/picopdio}{\textit{picopdio} -- Przykładowe radio internetowe Raspberry Pi Pico}
		\bibitem{radio_vs1003}
		\href{https://botland.com.pl/odtwarzacze-mp3-wav-ogg-midi/14308-odtwarzacz-mp3-vs1003-z-mikrofonem-5903351241786.html}{\textit{VS1003} -- Sprzętowy dekoder MP3}
		
		\bibitem{figma}
		\href{https://www.figma.com}{\textit{Figma} -- Narzędzie do projektowania interfejsów}
		
		\bibitem{pico_pdf}
		\href{https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf}{\textit{RP2040 Datasheet} -- dokumentacja techniczna procesora RP2040}
		\bibitem{tda_pdf}
		\href{http://www.lampizator.eu/lampizator/LINKS%20AND%20DOWNLOADS/DATAMINING/tda%201543.pdf}{\textit{TDA1543 Datasheet} -- dokumentacja techniczna układu DAC TDA1543}
		
		\bibitem{radio_browser_codecs}
		\href{https://www.radio-browser.info/codecs}{\textit{Radio browser codecs} -- kodeki audio wylistowane na stronie Radio Browser}
		\bibitem{helixmp3_pr}
		\href{https://github.com/ultraembedded/libhelix-mp3/pull/3}{\textit{helixmp3 pull request} -- ulepszenia biblioteki dekodującej}
		
		\bibitem{icy_spec}
		\href{https://gist.github.com/niko/2a1d7b2d109ebe7f7ca2f860c3505ef0#file-icy_meta-md}{\textit{ICY} -- protokół przesyłania metadanych}
		\bibitem{id3_spec_mutagen}
		\href{https://mutagen-specs.readthedocs.io/en/latest/id3/id3v2.4.0-structure.html}{\textit{ID3v2.4.0} -- protokół zapisu metadanych w plikach MP3}
		
		\bibitem{m3u}
		\href{https://en.wikipedia.org/wiki/M3U}{\textit{M3U} -- format zapisu playlist}
		\bibitem{pls}
		\href{https://en.wikipedia.org/wiki/PLS_(file_format)}{\textit{PLS} -- format zapisu playlist}
		
		\bibitem{ubuntu_font}
		\href{https://design.ubuntu.com/font}{\textit{Ubuntu font} -- czcionka wykorzystana do wyświetlania znaków}
		
	\end{thebibliography}
	
\end{document}
